[["index.html", "Perbandingan Smoothing, ARIMA, dan ARIMAX untuk prediksi harga minyak mentah Pendahuluan Struktur penelitian Ekstraksi data", " Perbandingan Smoothing, ARIMA, dan ARIMAX untuk prediksi harga minyak mentah Adley Dityo Valentinus Putra (G14180009) Muhammad Ammar Sahab (G14190020) Putri Eka Perdanti (G14190027) Farhan Narendra Achyara (G14190050) Grashella Clara Nesa Br Ginting (G14190086) 2022-04-26 Pendahuluan https://bookdown.org/mammarsahab3/LaporanMPDW/ Struktur penelitian Laporan ini akan membandingkan beberapa metode peralaman deret waktu untuk data harga minyak mentah. Metode tersebut akan dilatih menggunakan harga minyak mentah dari tahun 2009 sampai 2016, lalu diuji dengan meramal harga minyak mentah tahun 2017. Pembagian tersebut juga dilakukan di (He 2018), yang membandingkan model deret waktu seperti pemulusan dan ARIMA dengan model pembelajaran mesin (SVM). Berbeda dengan penelitian tersebut, penelitian ini akan menambahkan jenis pemulusan yang dipakai, serta mencoba menambahkan pengaruh peubah bebas dummy yang memodelkan efek hari setelah libur, peubahan struktural pada rezim harga minyak, dan lain-lain. Sekarang, penulisan laporan masih dalam tahap praproses dan eksplorasi data. Ekstraksi data Dataset yang digunakan sebagai berikut. Ambil data minyak dari tahun 2000 sampai sekarang Sys.Date() dengam bantuan library quantmod (Ryan dan Ulrich 2020): library(quantmod) library(dtplyr) library(dplyr) library(data.table) start &lt;- as.POSIXct(&quot;2000-08-23&quot;) end &lt;- as.POSIXct(Sys.Date()) getSymbols(Symbols = &quot;CL=F&quot;,src = &quot;yahoo&quot;, from = start, to = end) crude&lt;- lazy_dt(`CL=F`) %&gt;% mutate(X=as.Date(index,format=&quot;%d/%m/%Y&quot;)) %&gt;% select(X,`CL=F.Close`) Data tersebut merupakan harga kontrak berjangka minyak West Texas Intermediate (WTI) yang diperdangangkan di New York Mercantile Exchange (NYMEX). Peubah yang akan dimodelkan adalah harga close, atau harga minyak saat pasar ditutup: knitr::kable(head(crude,n=5), col.names = c(&quot;Tanggal&quot;,&quot;Harga Penutupan&quot;)) Tanggal Harga Penutupan 2000-08-23 32.05 2000-08-24 31.63 2000-08-25 32.05 2000-08-28 32.87 2000-08-29 32.72 Lakukan pembagian data. Data yang diambil selalu data terbaru karena menggunakan Sys.Date(): crude0917 &lt;-crude %&gt;% filter(X &gt;= as.Date(&quot;2009-01-01&quot;) &amp; X &lt;= as.Date(&quot;2017-12-31&quot;)) crudenow &lt;- crude %&gt;% filter(X &gt;= as.Date(&quot;2017-01-01&quot;) &amp; X &lt;= as.Date(Sys.Date())) %&gt;% data.table::as.data.table() Sudah diambil data yang relevan untuk diteliti. References "],["praproses-dan-eksplorasi-data.html", "Bab 1 Praproses dan Eksplorasi Data 1.1 Interval waktu data 1.2 Pola-pola data dan stasioneritas 1.3 Latar Belakang 1.4 Titik-titik perubahan struktural 1.5 Kestastioneran", " Bab 1 Praproses dan Eksplorasi Data Bagian ini akan membahas beberapa hal: Permasalahan interval waktu data Latar belakang fluktuasi harga minyak Ekstraksi peubah dummy untuk memodelkan efek hari libur dan perubahan struktural Pola data time series dan kestasioneran Identifikasi model. 1.1 Interval waktu data Dari melihat 10 tanggal pertama yang dicatat di dataset harga minyak: knitr::kable(head(crude0917,n=10), col.names = c(&quot;Tanggal&quot;,&quot;Harga Penutupan&quot;)) Tanggal Harga Penutupan 2009-01-02 46.34 2009-01-05 48.81 2009-01-06 48.58 2009-01-07 42.63 2009-01-08 41.70 2009-01-09 40.83 2009-01-12 37.59 2009-01-13 37.78 2009-01-14 37.28 2009-01-15 35.40 Terlihat bahwa rentang waktu pengamatan data tidak sama. Misal, tidak ada pengamatan saat 1 Januari 2009 karena ada libur tahun baru. Selain itu, ada lompatan dari 2 Januari 2009 ke 5 Januari 2009. Dalam kata lain, harga minyak tidak diamati pada tanggal 3 dan 4 Januari 2009, yang merupakan akhir minggu (hari Sabtu dan Minggu). Pola yang sama terulang di data deret waktu tersebut bagi akhir minggu dan hari libur lainnya - pasar ditutup sehingga harga minyak tidak ada. Situasi ini dapat ditangani dengan tiga cara umum: Abaikan rentang waktu harian yang tidak sama. Gunakan trading days atau hari kerja sebagai rentang waktu. Isi data akhir minggu dan hari libur menggunakan suatu bentuk interpolasi. Agregasikan data menjadi data mingguan, bulanan, atau tahunan. Cara pertama sering dipakai dalam peramalan deret waktu. Walaupun tidak ada data hari libur dan akhir minggu, nilai harian reksadana saham CREF dari tahun 2004 sampai 2006 dimodelkan dengan menggangap data tersebut memiliki rentang waktu yang sama (Cryer dan Chan 2008). Pemodelan harga emas harian dari tahun 1985 sampai 1989 juga hanya menggunakan trading days. Dilakukan interpolasi, tetapi hanya untuk data hilang di trading days (Hyndman dan Athanasopoulos 2018). Peramalan harga minyak (Elshendy et al. 2018) juga menggunakan data selama 84 hari kerja saja. Namun, juga ada justifikasi untuk interpolasi data. Interpolasi data dilakukan saat observasi tersebut dianggap memiliki nilai suatu peubah, tetapi tidak dapat diobservasi. Misal, tidak perlu melakukan interpolasi peubah gaji untuk seorang anak karena dia tidak mungkin bekerja. Dalam kasus ini, harga minyak di hari libur mungkin saja memiliki nilai. Pasar saham dan sekuritas sering mengalami after-hours trading; saat hal tersebut terjadi, harga berubah (Barclay dan Hendershott 2015). Walaupun begitu, bentuk proses tersebut harus diasumsikan untuk diinterpolasi. Misal, jika menggunakan interpolasi linear, diasumsikan bahwa pergerakan harga dari hari kerja ke hari kerja lainnya di hari libur konstan. Ini belum tentu benar - mungkin saja di hari Sabtu, harga masih naik dari hari Jumat, tetapi harga turun di hari Minggu. Interpolasi linear akan mengasumsikan harga turun di Sabtu dan Minggu. Oleh karena itu, interpolasi akan menghasilkan aproksimasi kasar dari proses after-hours trading. Agregasi data dapat menyelesaikan masalah tersebut karena hasil agregasi dianggap memiliki rentang waktu sama. Misal, mingguan atau bulanan. Agregasi ini harus mengikuti beberapa aturan (Stefan 2019). Untuk harga opening, akan diambil data harga open dari hari pertama di minggu/bulan tersebut - harga tersebut merupakan harga minyak saat pasar dibuka. Harga close diambil dari harga close hari terakhir di minggu/bulan tersebut - harga tersebut merupakan harga minyak saat pasar ditutup. Harga maksimum dan minimum memiliki logika yang mirip. Namun, agregasi data belum tentu menyelesaikan masalah rentang waktu tak sama. Ada beberapa bulan yang memiliki 28, 30, dan 31 hari. Ini berarti rentang pengamatan satu bulan dapat berarti beberapa jarak waktu yang berbeda. Data mingguan selalu memiliki rentang 7 hari jika data diambil dari hari yang sama di setiap minggu. Dalam kasus ini, ini berarti mengasumsikan data di hari Jumat selalu ada untuk closing, atau data hari Senin selalu ada. Mengingat rentang waktu yang cukup lama (8 tahun), kemungkinan besar ada data di hari-hari tersebut yang tidak ada. Dari beberapa pertimbangan tersebut, data akan dibiarkan dalam rentang waktu hari kerja. Metode ini sering dilakukan dalam penelitian dan relatif sederhana - tidak perlu dilakukan pemrosesan tambahan. Tidak perlu juga mengasumsikan struktur tertentu pada data hari libur. Namun, bisa jadi tidak adanya data hari libur tersebut membuat bias dalam model - misal, setelah hari libur biasanya ada lebih banyak pengunjung di toko-toko yang baru buka (Hyndman dan Athanasopoulos 2018). Untuk memodelkan efek hari libur tersebut, akan dibuat variabel dummy di hari-hari setelah libur dan akhir minggu. Variabel ini memodelkan fakta bahwa harga di hari Senin, misal, merespon informasi dari hari Sabtu, Minggu, dan Senin, tidak Senin saja. Sebelum itu, masih ada data hilang di hari kerja yang diimputasi: NAs&lt;-crude0917%&gt;% select(`CL=F.Close`) %&gt;% summarise(ties = sum(is.na(.))) knitr::kable(NAs, col.names=c(&quot;Jumlah NA&quot;)) Jumlah NA 3 Data hilang di data latih akan tetap di-interpolasi dengan fungsi na_interpolation dari package imputeTS (Moritz dan Gatscha 2021). Akan digunakan interpolasi default, yaitu interpolasi linear dengan rumus umum: \\[ y=y_{1}+(x-x_1)\\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \\] Jika dimiliki dua titik, dan hendak diduga nilai dari suatu titik di antara dua titik tersebut: \\[ \\begin{aligned} x_{1}&amp;: \\text{ Waktu pada titik ke-1}\\\\ y_{1}&amp;: \\text{ Harga minyak pada titik ke-1}\\\\ x_{2}&amp;: \\text{ Waktu pada titik ke-2}\\\\ y_{2}&amp;: \\text{ Harga minyak pada titik ke-2}\\\\ x&amp;: \\text{ Waktu pada titik yang ingin diketahui}\\\\ y&amp;: \\text{ Harga minyak pada titik yang ingin diketahui}\\\\ \\end{aligned} \\] library(imputeTS) ## ## Attaching package: &#39;imputeTS&#39; ## The following object is masked from &#39;package:zoo&#39;: ## ## na.locf #interpolasi crude0917&lt;- crude0917 %&gt;% mutate(fixed = na_interpolation(`CL=F.Close`)) ggplot_na_imputations(pull(crude0917,`CL=F.Close`), pull(crude0917,fixed)) Untuk mengekstraksi peubah dummy yang memodelkan efek hari setelah libur, buat sederet data yang berisi semua hari dari tahun 2009 sampai 2017, lalu merge: lazy_dt(seq(as.Date(&quot;2009-01-01&quot;), as.Date(&quot;2017-12-31&quot;), by=&quot;days&quot;)) %&gt;% rename(X=x) %&gt;% left_join(crude0917) %&gt;% select(fixed) %&gt;% summarise(ties = sum(is.na(.))) %&gt;% knitr::kable(col.names = &quot;Jumlah NA&quot;) Jumlah NA 1021 Terdapat 1021 data hilang. Buat deret hari akhir minggu dari tahun 2009 sampai 2017. Hari Sabtu pertama di dataset ini adalah Januari 3, 2009: sats&lt;-seq(as.Date(&quot;2009-01-03&quot;), as.Date(&quot;2017-12-31&quot;), by=&quot;weeks&quot;) suns&lt;-seq(as.Date(&quot;2009-01-04&quot;), as.Date(&quot;2017-12-31&quot;), by=&quot;weeks&quot;) length(c(sats,suns)) ## [1] 940 Ada 940 hari yang merupakan akhir minggu dari 1024 hari libur. Untuk mendapat data hari libur nasional di bursa saham New York, gunakan fungsi holidayNYSE dari package timeDate (Wuertz et al. 2018). library(timeDate) ## ## Attaching package: &#39;timeDate&#39; ## The following objects are masked from &#39;package:TSA&#39;: ## ## kurtosis, skewness length(as.Date(holidayNYSE(year=seq(2009,2017,1)))) ## [1] 80 Terlihat bahwa 1020 dari data hilang dapat dijelaskan oleh libur nasional dan akhir minggu. Hanya 1 dari data hilang yang tidak dapat dijelaskan. Buat deret hari Senin dari tahun 2009 sampai 2017, dan hari setelah hari libur nasional. Gunakan package dplyr (Wickham et al. 2022) untuk menghasilkan data.frame tersebut: mons&lt;-lazy_dt(suns+1)%&gt;%mutate(dumMon=1) posthol&lt;-lazy_dt(as.Date(holidayNYSE(year=seq(2009,2017,1)))+1) %&gt;% mutate(x=x+1, dumHol=1) Lalu, merge data crude dengan data hari Senin dan hari setelah libur nasional. crudeDummies&lt;- crude0917%&gt;% left_join(mons,by=c(&#39;X&#39;=&#39;x&#39;)) %&gt;% left_join(posthol,by=c(&#39;X&#39;=&#39;x&#39;)) %&gt;% mutate(dumMon=ifelse(is.na(dumMon),0,1), dumHol=ifelse(is.na(dumHol),0,1)) Peubah dummy untuk memodelkan efek pasar dibuka saat hari senin dan setelah libur telah dibuat. Peubah tersebut sebenarnya tidak terlalu berkorelasi dengan harga minyak, jadi mungkin saja efek-efek tersebut tidak ada: crudeDummies %&gt;% summarize(corHol=cor(dumHol,fixed), corMon=cor(dumMon,fixed)) %&gt;% knitr::kable(col.names = c(&quot;Senin&quot;, &quot;Liburan&quot;), caption = &quot;Korelasi peubah dummy dengan harga minyak&quot;) Table 1.1: Korelasi peubah dummy dengan harga minyak Senin Liburan 0.0038625 -0.0022236 1.2 Pola-pola data dan stasioneritas Plot dari data tersebut dibuat menggunakan ggplot2 (Wickham et al. 2021): library(ggplot2) data.table::as.data.table(crude0917) %&gt;% ggplot(aes(x=X, y=fixed)) + geom_line()+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() Terlihat bahwa data memiliki pola campuran. Secara kasar, terlihat tren naik pada tahun 2009-2011. Lalu, dari tahun 2011-2014 harga minyak siklik, tetapi rataannya tetap, kira-kira di atas 75 dolar. Harga minyak turun drastis dari tahun 2014-2016. Terakhir, harga minyak naik sedikit lalu stasioner lalu naik sedikit lagi di tahun 2016-2018. Pola-pola tersebut dapat dilihat setelah dilakukan segmentasi melalui dplyr (Wickham et al. 2022). Segmentasi tersebut tidak dilakukan menggunakan metode formal, tetapi secara eksploratif saja: library(dplyr) cbbPalette &lt;- c(&quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) #palet yang inklusif pada buta warna crude0917 %&gt;% mutate(Segmen= ifelse(X&lt;=as.Date(&#39;2010-12-31&#39;),&quot;1&quot;, ifelse(X&lt;=as.Date(&#39;2014-06-01&#39;),&quot;2&quot;, ifelse(X&lt;=as.Date(&#39;2016-01-01&#39;),&quot;3&quot;,&quot;4&quot;)))#buat segmentasi )%&gt;% data.table::as.data.table()%&gt;% ggplot(aes(x=X,y=fixed))+ geom_line(aes(color=Segmen))+scale_color_manual(values=cbbPalette)+ ggtitle(&quot;Segmentasi Harga Minyak (CL.F Close) - USD/Barrel&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+theme_classic() Namun, sebenarnya segmentasi ini belum terlalu detail. Misal, sebenarnya harga minyak naik dari tahun 2009 ke 2010, lalu mengalami pola siklik dari tahun 2010 ke 2011. Kekasasaran segmentasi ini dapat dilihat dari boxplot. Masih banyak titik-titik yang di luar garis (whisker), yang menandandakan ada banyak amatan ekstrim: crude0917 %&gt;% mutate(Segmen= ifelse(X&lt;=as.Date(&#39;2010-12-31&#39;),&quot;1&quot;, ifelse(X&lt;=as.Date(&#39;2014-06-01&#39;),&quot;2&quot;, ifelse(X&lt;=as.Date(&#39;2016-01-01&#39;),&quot;3&quot;,&quot;4&quot;)))#buat segmentasi )%&gt;% data.table::as.data.table()%&gt;% ggplot(aes(x=X,y=fixed))+ geom_boxplot(aes(fill=Segmen))+scale_fill_manual(values=cbbPalette)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+theme_classic() Selain detail pertama yang disebutkan di atas, terlihat bahwa di penurunan harga minyak tahun 2014-2016, sempat ada kenaikan sedikit lalu turun lagi. Dengan menambahkan segmen-segmen tersebut, segmentasi yang detail adalah: crude0917 %&gt;% mutate(Segmen= ifelse(X&lt;=as.Date(&#39;2009-10-01&#39;),&quot;1&quot;, ifelse(X&lt;=as.Date(&#39;2010-10-31&#39;),&quot;2&quot;, ifelse(X&lt;=as.Date(&#39;2014-06-30&#39;),&quot;3&quot;, ifelse(X&lt;=as.Date(&#39;2015-02-01&#39;),&quot;4&quot;, ifelse(X&lt;=as.Date(&#39;2016-05-01&#39;),&quot;6&quot;,&quot;7&quot;) ))))#buat segmentasi )%&gt;% data.table::as.data.table() %&gt;% ggplot(aes(x=X,y=fixed))+ geom_line(aes(color=Segmen))+scale_color_manual(values=cbbPalette)+ ggtitle(&quot;Segmentasi Detail Harga Minyak (CL.F Close) - USD/Barrel&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() Dapat dilihat dari boxplot per kelompok segmentasi tersebut bahwa sama sekali tidak ada amatan ekstrim yang menandakan bahwa pengelompokan sudah baik. crude0917 %&gt;% mutate(Segmen= ifelse(X&lt;=as.Date(&#39;2009-10-01&#39;),&quot;1&quot;, ifelse(X&lt;=as.Date(&#39;2010-10-31&#39;),&quot;2&quot;, ifelse(X&lt;=as.Date(&#39;2014-06-30&#39;),&quot;3&quot;, ifelse(X&lt;=as.Date(&#39;2015-02-01&#39;),&quot;4&quot;, ifelse(X&lt;=as.Date(&#39;2016-05-01&#39;),&quot;6&quot;,&quot;7&quot;) ))))#buat segmentasi )%&gt;% data.table::as.data.table() %&gt;% ggplot(aes(x=X,y=fixed))+ geom_boxplot(aes(fill=Segmen))+scale_fill_manual(values=cbbPalette)+ ggtitle(&quot;Boxplot per Segmen Harga Minyak (CL.F Close)&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() 1.3 Latar Belakang Variasi dari segmen tersebut dapat dijelaskan dengan beberapa faktor perubahan harga minyak, yaitu perubahan penawaran dan permintaan minyak mentah karena konflik yang melibatkan negara-negara penghasil minyak dan krisis ekonomi yang melanda negara-negara besar. 1.3.1 Harga Minyak Mentah Tahun 2009 Harga minyak pada awal 2009 sangat rendah karena efek krisis finansial yang melanda Amerika Serikat dan Eropa pada tahun 2008. Krisis finansial tersebut terjadi karena krisis pinjaman kredit yang terjadi di Amerika Serikat. Akibatnya, berbagai bank di Amerika Serikat bangkrut dan ekonomi dunia melemah. Setelah itu, permintaan minyak mentah juga melemah (karena minyak merupakan input besar di ekonomi dunia) dan harga minyak mentah turun dari titik tertinggi, yaitu 133.88 USD pada Juni 2008 ke 39.09 USD per barrel pada Februari 2009 (Li 2021). Pemerintah Amerika Serikat memberikan respons terhadap krisis tersebut dengan memberikan stimulus kepada pasar finansial seperti bank yang mengalami krisis keuangan. Akhirnya, ekonomi pada pertengahan 2009 mulai pulih dan permintaan minyak mentah meningkat kembali menjadi sekitar 70 USD per barrel pada Juni 2009 (Wearden 2009). Terlihat bahwa dari periode Januari 2009 sampai Desember 2010, harga kontrak berjangka minyak naik: highlightPalette&lt;-c( &quot;#56B4E9&quot;,&quot;#D55E00&quot;,&quot;#D3D3D3&quot;) crude0917 %&gt;% mutate(Keterangan= ifelse(X&lt;=as.Date(&#39;2009-06-01&#39;), &quot;Jan 2009 - Jun 2009 (Pemulihan Harga)&quot;, ifelse(X&lt;=as.Date(&#39;2010-12-17&#39;), &quot;Harga Stabil Sebelum Arab Spring&quot;, &quot;Lainnya&quot;))#buat segmentasi )%&gt;% data.table::as.data.table() %&gt;% ggplot(aes(x=X,y=fixed))+ geom_line(aes(color=Keterangan))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak Setelah Krisis 2008&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() 1.3.2 Arab Spring Peristiwa Arab Spring merupakan peristiwa politik yang terjadi di negara-negara Arab, seperti Mesir, Libya, Tunisia, dan lain-lain. Peristiwa tersebut dimulai sejak awal tahun 2011 yang menjadi titik awal perubahan sistem tatanan politik yang demokratis di negara-negara tersebut. Arab Spring memberikan implikasi penting terhadap pasar minyak internasional (Khan 2014). Konflik yang terjadi negara-negara Arab tersebut (yang merupakan pengekspor minyak terbesar) yang mengganggu proses produksi dan ekspor minyak dan gas bahkan turun sampai nol. Turunnya produksi tersebut yang biasanya menyumbang 5% dari produksi global mengakibatkan harga naik di seluruh dunia. Oleh karena itu, harga minyak siklik di atas 75 dolar per barrel pada waktu tersebut. highlightPalette&lt;-c(&quot;#56B4E9&quot;,&quot;#D3D3D3&quot;,&quot;#D3D3D3&quot;) crude0917 %&gt;% mutate(Keterangan= ifelse(X&lt;=as.Date(&#39;2010-12-17&#39;), &quot;Sebelum Arab Spring&quot;, ifelse(X&lt;=as.Date(&#39;2012-12-31&#39;),&quot;Arab Spring&quot;, &quot;Lainnya&quot;))#buat segmentasi )%&gt;% data.table::as.data.table() %&gt;% ggplot(aes(x=X,y=fixed))+ geom_line(aes(color=Keterangan))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak saat Arab Spring&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() Selain ketidakstabilan yang disebabkan Arab Spring, pertumbuhan ekonomi di Tiongkok meningkatkan permintaan minyak sehingga terdapat tekanan dalam permintaan dan penawaran untuk meningatkan harga minyak (Plumer 2014). 1.3.3 Shale Revolution Shale Revolution mengacu pada kombinasi rekahan hidrolik dan pengeboran horizontal yang memungkinkan Amerika Serikat untuk secara signifikan meningkatkan produksi minyak dan gas alamnya, terutama dari formasi minyak ketat, yang sekarang mencapai 36% dari total produksi minyak mentah AS. Kapasitas produksi baru ini telah mengurangi ketergantungan Amerika Serikat pada impor minyak dari luar negeri dan terus memberikan dorongan ekonomi yang penting saat negara itu pulih dari resesi 2008. Minyak dan gas merupakan 1,6% dari PDB Amerika Serikat pada tahun 2011 dan terus berkembang. Perkembangan formasi serpih telah berkorelasi dengan peningkatan lapangan kerja, dengan industri minyak dan gas menambahkan 169.000 pekerjaan antara 2010 dan 2012. highlightPalette&lt;-c(&quot;#D3D3D3&quot;,&quot;#D3D3D3&quot;,&quot;#56B4E9&quot;) crude0917 %&gt;% mutate(Keterangan= ifelse(X&lt;=as.Date(&#39;2014-01-01&#39;), &quot;Sebelum Shale Revolution&quot;, ifelse(X&lt;=as.Date(&#39;2016-01-01&#39;),&quot;Shale Revolution&quot;, &quot;Setelah Shale Revolution&quot;)) #buat segmentasi )%&gt;%data.table::as.data.table() %&gt;% ggplot(aes(x=X,y=fixed))+ geom_line(aes(color=Keterangan))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Penurunan Harga Minyak 2014-2016&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_classic() Perkembangan industri minyak dan gas tersebut meningkatkan produksi minyak dunia. Selain itu, negara-negara produsen minyak di OPEC mempertahankan atau meningkatkan produksi minyak mentah yang. Permintaan minyak di beberapa negara seperti Tiongkok dan di Uni Eropa juga menurun, sehingga faktor-faktor tersebut menurunkan harga minyak pada periode 2014-2016. Harga minyak mentah dunia mengalami penurunan pada akhir tahun 2014 dari US$100 per barel hingga US$40 per barel pada tahun 2016 dan mulai naik pada tahun 2017 (Mead dan Stiger 2015). 1.4 Titik-titik perubahan struktural Secara lebih formal, dapat dicari titik-titik perubahan struktural di deret waktu tersebut menggunakan fungsi breakpoints dari package strucchange (Zeileis et al. 2019). Algoritma yang dipakai cukup sederhana: dihitung BIC dan Jumlah Kuadrat Sisaan di tiap kemungkinan titik perubahan struktural. ika kita menggunakan model rata-rata yang sederhana seperti lm(y~1), terlihat bahwa dibutuhkan dua break point untuk data tersebut: library(strucchangeRcpp) breakOil&lt;-breakpoints(pull(crude0917,fixed)~1) plot(breakOil) RSS dan BIC turun drastis setelah menambah dua break point. Break point tersebut dapat diperlihatkan sebagai berikut: breakpoints(pull(crude0917,fixed)~1,breaks=2)$breakpoints ## [1] 461 1488 Breakpoint berada di observasi ke-461 (29 Oktober 2010) dan 1488 (26 November 2014) jika menggunakan dua breakpoint. Peubah yang menandakan segmen-segmen yang berbeda dapat dibuat (segmen pertama adalah observasi sebelum observasi ke-461, segmen kedua berada di antara observasi ke-461 dan 1488, dan segmen terakhir adalah observasi setelah observasi 1488). crudesegmented&lt;- crudeDummies %&gt;% mutate(B1=ifelse(X &gt;= nth(X,461) &amp; X &lt;= nth(X,1488),1,0), B2=ifelse(X &gt; nth(X,1488),1,0)) crude0917 %&gt;% data.table::as.data.table() %&gt;% ggplot(aes(x=X, y=fixed)) + geom_line()+ geom_vline(xintercept=as.Date(&#39;2010-10-29&#39;), col=&quot;darkred&quot;)+ geom_vline(xintercept=as.Date(&#39;2014-11-26&#39;), col=&quot;darkred&quot;)+ ggtitle(&quot;Harga Minyak (CL.F. Close)&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot;Harga&quot;)+ theme_classic() Segmentasi ini akan digunakan sebagai peubah dummy yang menjadi input model ARIMAX. Dapat dilihat matriks peubah dummy yang akan dipakai, termasuk segmentasi dan efek hari setelah libur: crudesegmented %&gt;% select(dumMon,dumHol,B1,B2) %&gt;% head(10) %&gt;% knitr::kable() dumMon dumHol B1 B2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Dapat dilihat bahwa peubah tersebut berkorelasi cukup tinggi dengan harga minyak: crudesegmented %&gt;% select(B1,B2,fixed) %&gt;% summarize(Break1=cor(B1,fixed), Break2=cor(B2,fixed)) %&gt;% knitr::kable() Break1 Break2 0.8605528 -0.8173909 Ekstraksi fitur tersebut sepertinya memiliki kemungkinan lebih baik untuk meningkatkan kebaikan model daripada fitur-fitur sebelumnya. 1.5 Kestastioneran ACF untuk menunjukkan ketakstasioneran data keseluruhan: acf(pull(crude0917,fixed), plot=T) ACF menuruan secara eksponensial hingga data tak stasioner. References "],["praproses-dan-eksplorasi-data-2017-2022.html", "Bab 2 Praproses dan Eksplorasi Data (2017-2022) 2.1 Interval waktu data 2.2 Plot data 2.3 Latar Belakang", " Bab 2 Praproses dan Eksplorasi Data (2017-2022) Bagian ini akan membahas beberapa hal: Permasalahan interval waktu data Latar belakang fluktuasi harga minyak pada tahun 2017-2022 Ekstraksi peubah dummy untuk memodelkan efek COVID-19 Pola data time series dan kestasioneran Identifikasi model. 2.1 Interval waktu data Dari melihat 10 tanggal pertama yang dicatat di dataset harga minyak: knitr::kable(head(crudenow,n=10), col.names = c(&quot;Tanggal&quot;,&quot;Harga Penutupan&quot;)) Tanggal Harga Penutupan 2017-01-03 52.33 2017-01-04 53.26 2017-01-05 53.76 2017-01-06 53.99 2017-01-09 51.96 2017-01-10 50.82 2017-01-11 52.25 2017-01-12 53.01 2017-01-13 52.37 2017-01-17 52.48 Terlihat bahwa rentang waktu pengamatan data tidak sama. Misal, tidak ada pengamatan saat 1 Januari 2009 karena ada libur tahun baru. Selain itu, ada lompatan dari 2 Januari 2009 ke 5 Januari 2009. Dalam kata lain, harga minyak tidak diamati pada tanggal 3 dan 4 Januari 2009, yang merupakan akhir minggu (hari Sabtu dan Minggu). Pola yang sama terulang di data deret waktu tersebut bagi akhir minggu dan hari libur lainnya - pasar ditutup sehingga harga minyak tidak ada. Situasi ini dapat ditangani dengan tiga cara umum: Abaikan rentang waktu harian yang tidak sama. Gunakan trading days atau hari kerja sebagai rentang waktu. Isi data akhir minggu dan hari libur menggunakan suatu bentuk interpolasi. Agregasikan data menjadi data mingguan, bulanan, atau tahunan. Cara pertama sering dipakai dalam peramalan deret waktu. Walaupun tidak ada data hari libur dan akhir minggu, nilai harian reksadana saham CREF dari tahun 2004 sampai 2006 dimodelkan dengan menggangap data tersebut memiliki rentang waktu yang sama (Cryer dan Chan 2008). Pemodelan harga emas harian dari tahun 1985 sampai 1989 juga hanya menggunakan trading days. Dilakukan interpolasi, tetapi hanya untuk data hilang di trading days (Hyndman dan Athanasopoulos 2018). Peramalan harga minyak (Elshendy et al. 2018) juga menggunakan data selama 84 hari kerja saja. Namun, juga ada justifikasi untuk interpolasi data. Interpolasi data dilakukan saat observasi tersebut dianggap memiliki nilai suatu peubah, tetapi tidak dapat diobservasi. Misal, tidak perlu melakukan interpolasi peubah gaji untuk seorang anak karena dia tidak mungkin bekerja. Dalam kasus ini, harga minyak di hari libur mungkin saja memiliki nilai. Pasar saham dan sekuritas sering mengalami after-hours trading; saat hal tersebut terjadi, harga berubah (Barclay dan Hendershott 2015). Walaupun begitu, bentuk proses tersebut harus diasumsikan untuk diinterpolasi. Misal, jika menggunakan interpolasi linear, diasumsikan bahwa pergerakan harga dari hari kerja ke hari kerja lainnya di hari libur konstan. Ini belum tentu benar - mungkin saja di hari Sabtu, harga masih naik dari hari Jumat, tetapi harga turun di hari Minggu. Interpolasi linear akan mengasumsikan harga turun di Sabtu dan Minggu. Oleh karena itu, interpolasi akan menghasilkan aproksimasi kasar dari proses after-hours trading. Agregasi data dapat menyelesaikan masalah tersebut karena hasil agregasi dianggap memiliki rentang waktu sama. Misal, mingguan atau bulanan. Agregasi ini harus mengikuti beberapa aturan (Stefan 2019). Untuk harga opening, akan diambil data harga open dari hari pertama di minggu/bulan tersebut - harga tersebut merupakan harga minyak saat pasar dibuka. Harga close diambil dari harga close hari terakhir di minggu/bulan tersebut - harga tersebut merupakan harga minyak saat pasar ditutup. Harga maksimum dan minimum memiliki logika yang mirip. Namun, agregasi data belum tentu menyelesaikan masalah rentang waktu tak sama. Ada beberapa bulan yang memiliki 28, 30, dan 31 hari. Ini berarti rentang pengamatan satu bulan dapat berarti beberapa jarak waktu yang berbeda. Data mingguan selalu memiliki rentang 7 hari jika data diambil dari hari yang sama di setiap minggu. Dalam kasus ini, ini berarti mengasumsikan data di hari Jumat selalu ada untuk closing, atau data hari Senin selalu ada. Mengingat rentang waktu yang cukup lama (8 tahun), kemungkinan besar ada data di hari-hari tersebut yang tidak ada. Untuk melihat apakah kemungkinan tersebut terjadi, ambil data per minggu. Lalu, kurangkan hari terakhir di minggu tersebut dengan hari terakhir di minggu sebelumnya untuk mendapatkan jarak antarminggu. Akan digunakan fungsi ISOweek dari package dengan nama yang sama (Block dan Hatto von Hatzfeld 2011) agar pembagian minggu mengikuti standar ISO 8601. Tabel lalu dimanipulasi menggunakan data.table (Dowle dan Srinivasan 2021), khusunya fungsi shift yang dapat memunculkan lag 1 dari variabel tertentu. library(ISOweek) library(data.table) weeklyCrude&lt;-crudenow[,Week:=ISOweek(X) ][,.(Date=last(X), Close=last(`CL=F.Close`)),by=list(Week) ][,Dist:=Date-shift(Date)] Tidak semua minggu memiliki jarak 7 hari. Ada beberapa minggu dengan jarak 6 dan 8 hari: knitr::kable(weeklyCrude[,.(count=.N),by=Dist], col.names = c(&quot;Jarak&quot;, &quot;Jumlah&quot;)) Jarak Jumlah NA days 1 7 days 258 6 days 9 8 days 9 3 days 1 Dapat diekstraksi peubah dummy dari minggu-minggu dengan jarak lebih dari 7 hari untuk memodelkan efek minggu-minggu tersebut. weeklyCrude[,Dist:=na.fill(Dist,type=&quot;const&quot;,fill=as.Date(7)) ][,`:=`(&quot;6DW&quot;=ifelse(Dist==6,1,0), &quot;8DW&quot;=ifelse(Dist==8,1,0))] Peubah tersebut nantinya dapat digunakan dalam pemodelan. Namun, sepertinya baik dummy dengan untuk minggu periode 6 hari dan 8 hari tidak berkorelasi terlalu besar dengan harga minyak saat penutupan pasar: knitr::kable(t(c(cor(weeklyCrude$`6DW`,weeklyCrude$Close,method=&quot;spearman&quot;), cor(weeklyCrude$`8DW`,weeklyCrude$Close,method=&quot;spearman&quot;))), col.names=c(&quot;6 Hari&quot;,&quot;8 hari&quot;), row.names=F) 6 Hari 8 hari 0.0036721 -0.0055715 2.2 Plot data Untuk melihat jenis data yang dihadapi, dapat di-plot data deret waktu mingguan harga minyak dari tahun 2017-2022 dengan ggplot2 (Wickham et al. 2021): ggplot(aes(x=Date, y=Close),data=weeklyCrude) + geom_line()+ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+ xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+theme_bw() Data jelas tidak stasioner. 2.3 Latar Belakang cbbPalette &lt;- c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#D3D3D3&quot;, &quot;#009E73&quot;, &quot;#CC79A7&quot;) highlightPalette&lt;-c(&quot;#D3D3D3&quot;,&quot;#00008b&quot;) weeklyCrude[,&quot;2017 - Siklik&quot;:=ifelse(Date&lt;=as.Date(&quot;2017-11-10&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`2017 - Siklik`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Di awal tahun 2017, harga minyak menurun karena komitmen produsen minyak di OPEC untuk memotong produksi minyak diragukan. Selain itu, turunnya volume ekspor Tiongkok menandakan kemungkinan lemahnya permintaan untuk minyak mentah (Kumar 2017 Jan). Namun, harga minyak sedikit naik di akhir Januari 2017 karena melemahnya dolar Amerika Serikat - minyak dibeli menggunakan dolar Amerika Serikat, sehingga dolar yang lebih lemah berarti negara pengimpor minyak dapat membeli lebih banyak minyak mentah yang meningkatkan permintaan (Gloystein 2017 Jan). Walaupun terdapat fenomena tersebut, pasokan minyak masih meningkat sehingga harga minyak turun sampai Maret. Arab Saudi berjanji untuk menurunkan produksi di bulan April, tetapi produksi minyak negara OPEC justru meningkat di bulan Juni sampai harga minyak mencapai titik terendahnya (Gloystein 2017 Jun). Janji OPEC untuk menurunkan produksi minyak dipenuhi di paruh kedua 2017 dan permintaan meningkat. Oleh karena itu, harga minyak meningkat sampai pulih ke level sebelum bulan Juni di bulan November (Gloystein 2017 Des). Secara umum, periode ini ditandakan dengan siklus. Negara OPEC berjanji menurunkan produksi (yang meningkatkan harga), tetapi produksi sebenarnaya masih tinggi (yang menurunkan harga) sehingga harga turun lalu naik. weeklyCrude[,&quot;Awal 2018 - harga naik&quot;:=ifelse(Date&gt;=as.Date(&quot;2017-11-10&quot;) &amp; Date&lt;=as.Date(&quot;2018-10-10&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`Awal 2018 - harga naik`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Harga minyak naik di akhir tahun 2017 sampai triwulan ketiga 2018. Selain turunnya produksi minyak oleh OPEC, terjadi gangguan pipa minyak di Libya dan Rusia yang menganggu distribusi minyak. Di awal Januari 2018, rendahnya pasokan minyak dunia meningkatkan harga. Walaupun terjadi sedikit penurunan karena Amerika Serikat berencana meningkatkan produksi (Gloystein 2018 Jan), negara-negara OPEC masih memotong produksi karena ingin meningkatkan harga minyak. Pada Maret sampai Mei 2018, harga minyak naik karena ketidakstabilan di Suriah, kemungkinan pembatasan impor minyak dari Iran, dan rendahnya produksi minyak OPEC dan Venezuela. weeklyCrude[,&quot;Akhir 2018 - harga turun&quot;:= ifelse(Date&gt;=as.Date(&quot;2018-10-10&quot;) &amp; Date&lt;=as.Date(&quot;2018-12-31&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`Akhir 2018 - harga turun`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Harga minyak turun drastis di akhir tahun 2018. Rusia dan Arab Saudi mengumumkan peningkatan produksi untuk menggantikan minyak Iran, pemerintah Amerika Serikat memberi dispensasi ke beberapa perusahaan Iran (Woolich et al. 2018), dan produksi shale oil as meningkat. Dari sisi penawaran, pasokan minyak meningkat yang menurunkan harga (DiChristopher 2018 Des). weeklyCrude[, &quot;Pra-COVID&quot;:= ifelse(Date&gt;=as.Date(&quot;2019-01-01&quot;) &amp; Date&lt;=as.Date(&quot;2020-02-03&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`Pra-COVID`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Tahun 2019 diawali dengan peningkatan harga minyak karena penurunan produksi dari Arab Saudi dan sanksi kepada Venezuela. Terdapat penurunan harga di bulan Februari karena melambatnya pertumbuhan ekonomi di Amerika Serikat, yang menghasilkan sedikit fluktuasi naik-turun, tetapi harga minyak tetap naik karena dispensasi ke eksportir minyak Iran berakhir dan pembatasan perdagangan minyak diberlakukan (2019). Namun, setelah mencapai puncak di bulan April, harga minyak turun di bulan Mei saat Amerika Serikat mengumumkan perang dagang dengan Tiongkok (Kumar 2019 Agu). Harga kembali naik di bulan Juni setelah Iran menjatuhkan drone Amerika Serikat, yang meningkatkan ketidakstabilan di Timur Tengah. Pengumuman tarif baru dalam perang dagang oleh Amerika Serikat menurunkan kembali harga minyak, tetapi ekspektasi penurunan produksi oleh OPEC meningkatkan harga minyak di November 2019. Secara umum, fluktuasi naik-turun terjadi karena tekanan perang dagang (yang menurunkan harga karena menurunkan permintaan minyak) dan tekanan dari OPEC serta ketidakstabilan Timur Tengah yag meningkatkan harga minyak. weeklyCrude[,&quot;COVID&quot;:= ifelse(Date&gt;=as.Date(&quot;2020-02-03&quot;) &amp; Date&lt;=as.Date(&quot;2020-04-30&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`COVID`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Harga minyak dunia terjun bebas dari Februari sampai April 2020. Pandemi COVID-19 mengurangi aktivitas ekonomi sehingga permintaan minyak berkurang. Karena itu, negara-negara OPEC setuju untuk mengurangi produksi, kecuali Rusia. Terjadi perang harga minyak antara Arab Saudi dan Rusia. Arab Saudi meningkatkan produksi dan memberikan diskon harga minyak, sampai minyak turun drastis (Calhoun 2020). Akhirnya, tekanan dari Amerika Serikat ke Arab Saudi (dan penurunan devisa Arab Saudi dan Rusia saat harga minyak rendah) membuat kedua negara setuju untuk memotong produksi. Namun, harga masih turun di akhir April sampai menjadi negatif karena biaya menyimpan minyak lebih mahal dari harga jualnya (Mills 2020 Apr). weeklyCrude[,&quot;Pemulihan&quot;:= ifelse(Date&gt;=as.Date(&quot;2020-04-30&quot;) &amp; Date&lt;=as.Date(&quot;2020-10-24&quot;),T,F)] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`Pemulihan`))+scale_color_manual(values=highlightPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Setelah bulan April, penurunan produksi minyak OPEC dan Amerika Serikat mulai memiliki efek dan harga minyak kembali meningkat. Di bulan Juli harga minyak turun sedikit karena menguatnya dolar (sehingga pengimpor minyak susah membeli minyak), rendahnya permintaan, dan pasokan Amerika Serikat yang lebih tinggi dari harapan. Berita mengenai Presiden Amerika Serikat pada bulan Oktober, Donald Trump, yang terkena COVID juga menurunkan harga minyak. Namun, fluktuasi tersebut relatif kecil dibandingkan fluktuasi-fluktuasi yang terjadi saat awal COVID. Berita mengenai vaksin COVID di akhir 2020 (Pfizer 2020 Nov) meningkatkan kepercayaan bahwa ekonomi dunia akan kembali pulih, dan harga minyak mulai naik. weeklyCrude[,&quot;Vaksin, Varian&quot;:= ifelse(Date&gt;=as.Date(&quot;2020-10-24&quot;) &amp; Date&lt;=as.Date(&quot;2021-02-13&quot;), &quot;Vaksinasi&quot;, ifelse(Date&gt;=as.Date(&quot;2021-02-02&quot;) &amp; Date&lt;=as.Date(&quot;2021-05-07&quot;), &quot;Alpha&quot;, ifelse(Date&gt;=as.Date(&quot;2021-05-07&quot;) &amp; Date&lt;=as.Date(&quot;2021-09-01&quot;), &quot;Delta&quot;, ifelse(Date&gt;=as.Date(&quot;2021-09-01&quot;) &amp; Date&lt;=as.Date(&quot;2021-12-01&quot;), &quot;Omicron&quot;,&quot;Lainnya&quot;))))] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`Vaksin, Varian`))+scale_color_manual(values=cbbPalette)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Tren umum harga minyak naik karena optimisme mengenai vaksin. OPEC juga masih membatasi produksi pada awal tahun 2021. Namun, tren tersebut tidak mulus karena muncul beberapa varian COVID-19. Varian Alpha disebut variant of concern pada Februari 2021. Harga minyak turun karena infeksi dari varian Alpha meningkat. Lalu, setelah varian tersebut teratasi, pemulihan ekonomi dunia meningkatkan harga minyak. Delta mulai disebut variant of conern pada Mei 2021, dan di beberapa negara peningkatan kasus dari Delta masih ada sampai bulan September. Harga minyak turun (2021 Agu). Namun, badai Ida di Amerika Serikat yang mengaggu produksi minyak, penurunan produksi OPEC, dan perbaikan hubungan Amerika Serikat-Tiongkok meningkatkan harga minyak. Saat varian Omicron muncul, harga minyak turun lagi (Resnick-ault 2021 Des). cbbPalette2 &lt;- c(&quot;#D3D3D3&quot;,&quot;#E69F00&quot;, &quot;#56B4E9&quot;) weeklyCrude[,&quot;2022&quot;:= ifelse(Date&gt;=as.Date(&quot;2021-12-01&quot;) &amp; Date&lt;=as.Date(&quot;2022-02-24&quot;), &quot;Pemulihan Omicron&quot;, ifelse(Date&gt;=as.Date(&quot;2022-02-24&quot;),&quot;Perang Ukraina-Russia&quot;,&quot;Lainnya&quot;))] ggplot(aes(x=Date, y=Close), data=weeklyCrude)+ geom_line(aes(color=`2022`))+scale_color_manual(values=cbbPalette2)+ ggtitle(&quot;Harga Minyak (CL.F. Close) - USD/Barrel&quot;)+xlab(&quot;Waktu&quot;)+ylab(&quot; &quot;)+ theme_bw() Harga minyak naik di awal tahun 2022 setelah varian Omicron ditemukan memiliki tingkat kematian lebih rendah. Stok minyak di Amerika Serikat menurun, dan stok di Uni Emirat Arab terganggu setelah negara tersebut diserang oleh Houthi. Lalu, perang Rusia-Ukraina pada 24 Februari 2022 meningkatkan harga minyak secara drastis karena impor minyak dari Rusia dapat dihentikan oleh Amerika Serikat dan negara Eropa Barat. Harga minyak turun dari puncaknya di awal Maret setelah Amerika Serikat bernegosiasi dengan Iran dan Venezuela untuk mengganti pasokan minyak, mulai ada perundingan antara Rusia dan Ukraina, serta rencana Amerika Serikat untuk mengeluarkan pasokan strategis minyaknya (Mattingly et al. 2022). Dampak invasi Rusia ke Ukraina sangat signifikan terhadap harga minyak di negara-negara barat terutama Eropa yang sangat bergantung terhadap minyak dari Rusia. Invasi tersebut menyebabkan disrupsi suplai minyak dari Rusia akibat perang dan rencana embargo minyak mentah karena agresi Rusia mulai diperbincangkan. Harga minyak yang tinggi juga berpengaruh terhadap harga komoditas pangan karena logistik dari satu tempat ke tempat lainnya membutuhkan bahan bakar minyak (Islam 2022). Selain negara-negara barat, dampak harga minyak juga terasa di negara-negara Asia. Meskipun nilai perdagangan dengan Rusia rendah, kenaikan harga komoditas pangan akibat logistik yang terganggu akan mengakibatkan inflasi semakin parah dan menghambat pemulihan ekonomi pasca pandemi. Untuk mengatasi hal tersebut, berbagai negara seperti Korea dan Jepang memberlakukan subsidi harga minyak untuk meminimalkan dampak ekonomi dari tingginya harga minyak (Kammer et al.). References "],["optimisasi-parameter-pemulusan-dengan-validasi-silang.html", "Bab 3 Optimisasi Parameter Pemulusan dengan Validasi Silang 3.1 Metode 3.2 Single Moving Average 3.3 Validasi silang untuk SMA 3.4 DMA 3.5 SES 3.6 DES 3.7 Kesimpulan 3.8 Addendum: Last Block", " Bab 3 Optimisasi Parameter Pemulusan dengan Validasi Silang library(smoothCV) 3.1 Metode 3.1.1 Validasi Silang Deret Waktu Validasi silang deret waktu merupakan modifikasi yang lebih canggih dari pembagian training dan testing. Salah satu variasi dari prosedur ini menghasilkan beberapa data uji yang tersusun atas satu observasi. Data latih merupakan semua observasi sebelum data uji tersebut. Beberapa observasi awal menjadi data latin (Hyndman dan Athanasopoulos 2021). Akurasi dihitung dengan merata-ratakan dari beberapa iterasi. Cerqueira et al. (2020) mengevaluasi modifikasi dari algoritma di atas. Data dibagi menjadi beberapa blok - blok pertama menjadi data latih dan blok kedua menjadi data uji. Di iterasi selanjutnya, blok pertama dan kedua menjadi data latih dan blok ketiga menjadi data uji, dan seterusnya. Algoritma tersebut dibandingkan dengan sliding window, di mana blok-blok sebelumnya dilupakan (di iterasi kedua, blok kedua menjadi data latih dan blok ketiga menjadi data uji), dan algoritma lain yang memberikan gap. Algoritma tersebut dibandingkan dengan holdout (latih-uji tradisional) dan repeated holdout - algoritma di mana sebagian data telah dibagi menjadi training dan testing, tetapi titik pemisahan eksaknya dicari secara acak (misal, titik pemisahannya berada di antara \\(70\\%-90\\%\\) - akan dicari angka acak antara angka tersebut). Metode validasi silang berperforma baik di data sintetis \\(AR(3)\\) dan \\(SAR\\), tetapi berperforma di bawah rata-rata untuk \\(MA(1)\\). Validasi silang berperforma baik di 31 deret waktu stasioner, tetapi kurang baik di 31 deret waktu non-stasioner. Repeated holdout nampaknya berperforma paling baik. Schnaubelt (2019) melakukan simulasi metode tersebut di suatu deret waktu yang mengalami perubahan mean dan ragam setelah periode waktu tertentu. Secara umum, untuk metode validasi silang dengan blok yang membesar berperforma paling baik saat gangguan tidak sangat besar (koefisien berubah kurang dari \\(15\\%\\)). Selebihnya metode holdout lebih baik. Dalam implementasinya ke harga minyak, akan digunakan algoritma validasi silang: Pilih n data awal sebagai training. Bagi sisanya jadi beberapa fold buat testing. Fold ke-1 menjadi testing di iterasi 1, fold ke-2 jadi testing di iterasi 2 Untuk tiap iterasi: Hitung error Gabungkan data testing ke data training. Gunakan fold selanjutnya sebagai testing. Ini analog dengan validasi silang dengan blok yang membesar. COVID dan perang Ukraina-Rusia dapat dianggap sebagai gangguan pada harga minyak, tetapi perubahan koefisien secara khusus tidak diketahui. Dapat dianggap gangguan tersebut tidak besar karena tren harga minyak sebelum perang masih naik. Semisal gangguan tersebut besar, ambil saja data dengan iterasi terakhir. 3.1.2 Metrik Ada tiga metrik yang akan dipakai. Diskusi metrik tersebut terkandung di Hyndman dan Athanasopoulos (2021): \\[ MSE=\\frac{1}{n}\\sum_{i=1}^n (y_t-\\hat{y}_t)^2 \\] MSE secara umum memboboti outlier secara lebih besar. Suatu contoh numerik sederhana: anggap ada gugus data dengan error (1,1,1), dan gugus data lain dengan error (0,0,3). Maka: \\[ MSE_1=\\frac{1}{3}(1^2+1^2+1^2)=1\\\\ MSE_2=\\frac{1}{3}(0^2+0^2+3^2)=3 \\] Secara absolut, error sama tetapi di gugus kedua ada outlier: \\[ MAPE=\\frac{1}{n}\\sum_{i=1}^n \\left|\\frac{y_t-\\hat{y}_t}{y_t}\\right| \\] Note, MAPE lebih memboboti observasi dengan nilai amatan kecil. Artinya, overestimasi diboboti lebih besar dari underestimasi. Contoh numerik lain, anggap dugaan adalah 2. Semisal nilai asli adalah 3, atau 1: \\[ \\begin{aligned} MAPE_1&amp;= \\left|\\frac{2-1}{1}\\right|=1\\\\ MAPE_2&amp;= \\left|\\frac{2-3}{1}\\right|=\\frac{1}{3} \\end{aligned} \\] Dan MAE: \\[ MAE=\\frac{1}{n}\\sum_{i=1}^n \\left|y_t-\\hat{y}_t\\right| \\] 3.2 Single Moving Average Single Moving Average adalah suatu teknik pemulusan yang bertujuan untuk melihat grafik secara eksploratif dengan cara menghitung rata-rata periode sekarang dengan periode sebelumnya. Hal ini berguna untuk melihat pola dari suatu data tanpa dipengaruhi data harian yang bergerak lebih ekstrem (Montgomery et al. 2008). Rumus dari Single Moving Average adalah: \\[ \\begin{aligned} M_{T} = \\left[y_{T} + y_{(T-1)} + ... + y_{(T-n+1)}\\right]/n = 1/N \\\\ \\sum_{t=T-n+1}^{T} y_{t} \\end{aligned} \\] 3.3 Validasi silang untuk SMA Lakukan validasi silang untuk SMA dengan jumlah data latih awal sebesar 36 untuk mendapat parameter optimal. Selebihnya, data dibagi menjadi 15 fold sehingga ada \\((276-36)/15=16\\) observasi di tiap fold. Nilai M yang diuji adalah dari 2 sampai 30. SMACV&lt;-fcCV(weeklyCrude[,3],initialn=36,folds=15,type=&quot;SMA&quot;,start=2,end=30,dist=1) Hasil dari prosedur tersebut: resultSMA&lt;-SMACV[[3]] Buat boxplot untuk melihat M yang meminimumkan error: library(ggplot2) ggplot(resultSMA,aes(x=M,y=MSE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE tiap M untuk SMA&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Dapat dilihat bahwa median MSE cenderung sama di tiap nilai parameter M. Setelah melewati \\(M=20\\), median baru terlihat naik. Namun, keragaman dari boxplot cenderung terus meningkat jika nilai parameter bertambah. Hampir semua boxplot memiliki pencilan. Bagaimana dengan MAPE? library(ggplot2) ggplot(resultSMA,aes(x=M,y=MAPE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap M untuk SMA&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Hasil cukup mirip dengan MSE, tetapi ada sedikit perbedaan. Nilai pencilan pada boxplot MAPE cenderung meningkat seiring dengan bertambahnya nilai parameter M sampai \\(M=10\\), lalu stagnan. Bagaimana dengan MAE: ggplot(resultSMA,aes(x=M,y=MAE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE tiap M untuk SMA&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Garis median terlihat sedikit menaik saat nilai parameter M makin membesar. Nilai outlier di nilai \\(M\\leq 6\\) terlihat menggerombol, sedangkan makin banyak M salah satu outlier bergabung ke boxplot dan satu lagi menjauh dari boxplot. Boxplot membesar sehingga kesalahan lebih beragam saat makin besar M. Lanjutkan dengan buat agregasi: aggregateSMA&lt;-resultSMA[,`.`(meanMSE=mean(MSE), varMSE=var(MSE), meanMAPE=mean(MAPE), varMAPE=var(MAPE), meanMAE=mean(MAE), varMAE=var(MAE)), by=list(M)] Jika dilihat nilai M yang meminimumkan mean dari MSE, MAPE, dan MAE: knitr::kables(list( knitr::kable(head(setorder(aggregateSMA, meanMSE)[,c(1,2)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateSMA, meanMAPE)[,c(1,4)],n=7), col.names = c(&quot;M&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateSMA, meanMAE)[,c(1,6)],n=7), col.names = c(&quot;M&quot;,&quot;MAE&quot;)) ), caption=&quot;Rata-rata dari metrik akurasi untuk tiap nilai M (SMA).&quot; ) Table 3.1: Rata-rata dari metrik akurasi untuk tiap nilai M (SMA). M MSE 2 108.0670 3 114.7901 4 118.5380 5 125.9310 6 132.4537 7 135.9281 8 139.0788 M MAPE 2 14.60480 3 14.92289 4 15.17458 5 15.56182 6 16.18383 7 16.87461 8 17.63472 M MAE 2 7.290667 3 7.468417 4 7.634146 5 7.846216 6 8.134944 7 8.387143 8 8.673552 Nilai MSE dan MAPE berurutan dari 2, 3, , 8 dari yang terkecil hingga terbesar. Kemudian, hitung nilai M yang meminimumkan ragam MSE dan MAPE: knitr::kables(list( knitr::kable(head(setorder(aggregateSMA, varMSE)[,c(1,3)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateSMA, varMAPE)[,c(1,5)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateSMA, varMAE)[,c(1,7)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)) ), caption=&quot;Ragam dari metrik akurasi per iterasi untuk tiap nilai M (SMA).&quot; ) Table 3.2: Ragam dari metrik akurasi per iterasi untuk tiap nilai M (SMA). M MSE 2 33470.24 3 39948.60 4 41435.88 5 47620.23 11 48140.85 8 48188.65 10 48264.50 M MSE 2 397.2491 4 434.3998 3 435.2714 5 446.5725 6 467.8972 7 507.1456 8 540.2385 M MSE 2 37.56372 3 41.68619 4 42.28482 12 44.68658 11 44.71050 10 45.01530 13 45.01998 Urutan nilai M yang meminimumkan ragam metrik-metrik tersebut sedikit berbeda. Walaupun \\(M=2\\) memiliki performa terbaik dalam meminimumkan rata-rata metrik, \\(M=3\\) sepertinya lebih baik dalam meminimumkan ragam dari metrik-metrik tersebut. Ini secara umum berarti kesalahan-kesalahan dari \\(M=3\\) akan lebih sering mendekati suatu nilai tertentu, walaupun rataannya lebih besar dari \\(M=2\\). Dapat dipilih dua nilai tersebut sebagai parameter optimal. Setelah itu, cari iterasi-iterasi yang memiliki akurasi rendah: library(ggplot2) ggplot(resultSMA,aes(x=iter,y=MSE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot untuk iterasi ke-9 (saat pandemi) dan ke-15 (pasca pandemi dan perang Rusia-Ukraina) memiliki rataan dan keragaman yang cukup besar dibandingkan iterasi lainnya pada data testing karena adanya fluktuasi yang ekstrem pada rentang waktu tersebut. Fluktuasi tersebut tidak cocok untuk SMA karena kurang dapat menangani data dengan tren. library(ggplot2) ggplot(resultSMA,aes(x=iter,y=MAPE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot untuk iterasi ke-15 ternyata tidak memiliki MAPE besar. Ini terjadi karena MAPE lebih memboboti observasi dengan nilai amatan kecil (COVID saat harga minyak turun) daripada saat nilai amatan besar (Ukraina-Rusia saat terjadi inflasi harga minyak). library(ggplot2) ggplot(resultSMA,aes(x=iter,y=MAE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot MAE per iterasi mengikuti boxplot MSE - terjadi performa buruk di iterasi ke-9 dan 15. 3.3.1 Kesimpulan Berdasarkan nilai rataan dan ragam MSE dan MAPE, parameter m untuk metode SMA yang dipakai adalah saat M = 2 dan 3. 3.4 DMA Lakukan validasi silang untuk DMA dengan jumlah data latih awal sebesar 36 untuk mencari nilai parameter optimum. Selebihnya, data dibagi menjadi 15 fold sehingga ada \\((276-36)/15=16\\) observasi di tiap fold. Nilai M yang diuji adalah dari 2 sampai 16. DMACV&lt;-fcCV(weeklyCrude[,3],initialn=36,folds=15,type=&quot;DMA&quot;,start=2,end=16,dist=1) Ambil hasil dari prosedur tersebut: resultDMA&lt;-DMACV[[3]] Buat boxplot untuk melihat M yang meminimumkan error: library(ggplot2) ggplot(resultDMA,aes(x=M,y=MSE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE tiap M&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Dapat dilihat bahwa error dari tiap parameter cukup bervariasi di tiap iterasi. Hampir semua boxplot memiliki pencilan yang sangat jauh dari kebanyakan observasi. Namun, terlihat bahwa di \\(9\\leq M\\leq 12\\) keragamanboxplot lebih kecil, outlier lebih dekat, dan garis median lebih rendah dari boxplot lainnya. Ini berarti MSE di DMA dengan parameter tersebut biasanya rendah dan tidak beragam. Bagaimana dengan MAPE? library(ggplot2) ggplot(resultDMA,aes(x=M,y=MAPE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap M&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Hasil cukup mirip dengan MSE, tetapi ada sedikit perbedaan. Terlihat bahwa di \\(4\\leq M \\leq 7\\), boxplot tidak memiliki pencilan sama sekali. Justru, daerah yang sebelumnya dianggap baik, \\(9 \\leq M \\leq 12\\) memiliki beberapa pencilan walaupun boxplot di daerah tersebut menunjukkan keragaman lebih kecil di antara kuantil pertama sampai ketiga. library(ggplot2) ggplot(resultDMA,aes(x=M,y=MAE,group=M))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE tiap M&quot;)+ xlab(&quot;M&quot;)+ylab(&quot; &quot;) Boxplot MAE memiliki pola yang mengikuti MSE. Untuk memastikan, buat agregasi data error dari tiap nilai M: aggregateDMA&lt;-resultDMA[,`.`(meanMSE=mean(MSE), varMSE=var(MSE), meanMAPE=mean(MAPE), varMAPE=var(MAPE), meanMAE=mean(MAE), varMAE=var(MAE)), by=list(M)] Jika dilihat nilai M yang meminimumkan mean dari MSE: knitr::kables(list( knitr::kable(head(setorder(aggregateDMA, meanMSE)[,c(1,2)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDMA, meanMAPE)[,c(1,4)],n=7), col.names = c(&quot;M&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDMA, meanMAE)[,c(1,6)],n=7), col.names = c(&quot;M&quot;,&quot;MAE&quot;)) ), caption=&quot;Rata-rata metrik akurasi di semua iterasi untuk tiap nilai M&quot; ) Table 3.3: Rata-rata metrik akurasi di semua iterasi untuk tiap nilai M M MSE 11 118.3255 12 118.6915 10 133.1766 13 139.3820 9 165.7192 14 169.9829 15 197.5252 M MAPE 10 15.02806 9 15.67344 11 15.67879 12 16.39718 8 17.76458 13 17.99311 7 19.33181 M MAE 12 7.523578 11 7.578989 10 7.805900 13 8.056381 9 8.568045 14 9.024821 15 9.891670 Tampak bahwa nilai M=10 cukup konsisten baik (ranking 2) di MSE, MAPE, dan MAE. Nilai M=11 juga meminimumkan nilai harapan MAE dan MSE, tetapi tidak meminimumkan nilai harapan MAPE. Bagaimana dengan ragam dari MSE, MAPE, dan MAE? knitr::kables(list( knitr::kable(head(setorder(aggregateDMA, varMSE)[,c(1,3)],n=7), col.names = c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDMA, varMAPE)[,c(1,5)],n=7), col.names = c(&quot;M&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDMA, varMAE)[,c(1,7)],n=7), col.names = c(&quot;M&quot;,&quot;MAE&quot;)) ), caption=&quot;Ragam metrik akurasi di semua iterasi untuk tiap M&quot; ) Table 3.4: Ragam metrik akurasi di semua iterasi untuk tiap M M MSE 12 34548.72 11 38944.08 13 48830.32 10 65084.47 14 78964.40 2 106858.62 15 109681.57 M MAPE 8 221.3336 9 230.1605 2 239.9527 10 303.3681 3 303.9728 7 309.7535 4 355.4908 M MAE 11 39.34564 12 44.04738 10 46.03796 3 53.34972 2 55.22787 13 56.67645 9 61.33235 M=10 dan 11 konsisten baik di berbagai metrik kecuali ragam dari MAPE. Dapat juga dilihat iterasi mana yang memiliki kesalahan tinggi: library(ggplot2) ggplot(resultDMA,aes(x=iter,y=MSE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Error terbesar ada di iterasi 5, 9, 10, dan 15. Iterasi 15 merupakan perang Rusia-Ukraina. Ada apa di iterasi 9 dan 10 tersebut? knitr::kables(list( knitr::kable(c(DMACV[[1]][5],DMACV[[2]][5]),col.names = &quot;Range data iterasi 5&quot;), knitr::kable(c(DMACV[[1]][9],DMACV[[1]][10],DMACV[[2]][10]),col.names = &quot;Range data iterasi 9-10&quot;) ) ) Range data iterasi 5 101.5333 116.6667 Range data iterasi 9-10 166.0667 182.2000 197.3333 Cari tanggal tanggal tersebut: knitr::kable(weeklyCrude[,2][c(101,116,165,181,196)]) Date 2018-12-07 2019-03-22 2020-02-28 2020-06-19 2020-10-02 Dari 2018-2019, harga turun. Tentu, 2020 adalah COVID. Namun, dari MSE terlihat bahwa performa DMA beragam. Di SMA, di iterasi tersebut boxplot hampir homogen memiliki nilai error tinggi. Ini berarti, ada nilai-nilai M tertentu yang dapat meminimukan error di data tren tersebut. library(ggplot2) ggplot(resultDMA,aes(x=iter,y=MAE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Profil boxplot MAE untuk iterasi relatif sama dengan boxplot MSE. library(ggplot2) ggplot(resultDMA,aes(x=iter,y=MAPE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) MAPE tidak memboboti error saat perang Ukraina dan Rusia, sama seperti saat SMA. Parameter terbaika dalah \\(M=10\\) dan \\(M=11\\). 3.5 SES SESCV&lt;-fcCV(weeklyCrude[,3],initialn=36,folds=15,type=&quot;SES&quot;,alphrange=seq(0.01,1,0.01)) Masukkan hasilnya: resultSES&lt;-SESCV[[3]] Karena ada 100 nilai alpha yang berbeda, tidak praktis untuk membuat boxplot untuk semua nilai tersebut. Bulatkan nilai alpha sebesar satu desimal \\((0.1, 0.2, \\ldots)\\) lalu buat boxplot. Gunakan latex2exp (Meschiari 2022) untuk menghasilkan teks judul dan sumbu x dengan simbol \\(\\alpha\\): library(latex2exp) ggplot(resultSES,aes(x=alpha,y=MSE,group=round(alpha,1)))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE di tiap alpha&quot;)+ xlab(TeX(r&#39;($\\alpha$)&#39;))+ylab(&quot; &quot;) Sepertinya, makin besar nilai alpha hasil pemulusan semakin baik. Ini berarti bobot observasi sekarang lebih besar dari observasi sebelumnya. : ggplot(resultSES,aes(x=alpha,y=MAE,group=round(alpha,1)))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE di tiap alpha&quot;)+ xlab(TeX(r&#39;($\\alpha$)&#39;))+ylab(&quot; &quot;) MAE nampaknya juga mengikuti pola tersebut. ggplot(resultSES,aes(x=alpha,y=MAPE,group=round(alpha,1)))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE di tiap alpha&quot;)+ xlab(TeX(r&#39;($\\alpha$)&#39;))+ylab(&quot; &quot;) MAPE juga mengikuti pola umum tersebut, tetapi nampaknya di \\(\\alpha=0.5\\) nilai pencilan minimum. Lakukan agregasi: aggregateSES&lt;-resultSES[,`.`(meanMSE=mean(MSE), varMSE=var(MSE), meanMAPE=mean(MAPE), varMAPE=var(MAPE), meanMAE=mean(MAE), varMAE=var(MAE)), by=list(alpha)] Jika dilihat nilai \\(\\alpha\\) yang meminimumkan mean dari MSE, MAPE, MAE: knitr::kables(list( knitr::kable(head(setorder(aggregateSES, meanMSE)[,c(1,2)],n=20), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MSE&#39;)), knitr::kable(head(setorder(aggregateSES, meanMAPE)[,c(1,4)],n=20), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MAPE&#39;)), knitr::kable(head(setorder(aggregateSES, meanMAE)[,c(1,6)],n=20), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MAE&#39;)) ), caption=&quot;Rata-rata metrik akurasi untuk semua iterasi di tiap nilai $\\\\alpha$&quot; ) Table 3.5: Rata-rata metrik akurasi untuk semua iterasi di tiap nilai \\(\\alpha\\) \\(\\alpha\\) MSE 1.00 94.34572 0.99 94.58195 0.98 94.82050 0.97 95.06133 0.96 95.30443 0.95 95.54979 0.94 95.79740 0.93 96.04725 0.92 96.29936 0.91 96.55372 0.90 96.81035 0.89 97.06929 0.88 97.33055 0.87 97.59417 0.86 97.86020 0.85 98.12867 0.84 98.39964 0.83 98.67317 0.82 98.94932 0.81 99.22817 \\(\\alpha\\) MAPE 1.00 13.23114 0.99 13.25724 0.98 13.28320 0.97 13.30903 0.96 13.33471 0.95 13.36027 0.94 13.38568 0.93 13.41095 0.92 13.43609 0.91 13.46108 0.90 13.48594 0.89 13.51065 0.88 13.53523 0.87 13.55967 0.86 13.58408 0.85 13.60837 0.84 13.63287 0.83 13.65772 0.82 13.68243 0.81 13.70701 \\(\\alpha\\) MAE 1.00 6.853250 0.99 6.861433 0.98 6.869597 0.97 6.877744 0.96 6.885874 0.95 6.893986 0.94 6.902082 0.93 6.910161 0.92 6.918225 0.91 6.926272 0.90 6.934305 0.89 6.942323 0.88 6.950327 0.87 6.958318 0.86 6.966374 0.85 6.974426 0.84 6.982615 0.83 6.991064 0.82 6.999505 0.81 7.007941 Nilai-nilai dari tabel ini cukup kontradiktif. Untuk meminimumkan MSE, sebaiknya mengambil \\(\\alpha\\) sekitar 0.9. MAPE minimum di \\(\\alpha\\) 0.6 sampai 0.7, sedangkan MAE minimum di \\(\\alpha\\) 0.8. Bagaimana dengan ragam dari MSE, MAPE, dan MAE? knitr::kables(list( knitr::kable(head(setorder(aggregateSES, varMSE)[,c(1,3)],n=7), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MSE&#39;)), knitr::kable(head(setorder(aggregateSES, varMAPE)[,c(1,5)],n=7), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MAPE&#39;)), knitr::kable(head(setorder(aggregateSES, varMAE)[,c(1,7)],n=7), col.names = c(&quot;$\\\\alpha$&quot;,&#39;MAE&#39;)) ), caption=&quot;Ragam metrik akurasi untuk semua iterasi di tiap nilai $\\\\alpha$&quot; ) Table 3.6: Ragam metrik akurasi untuk semua iterasi di tiap nilai \\(\\alpha\\) \\(\\alpha\\) MSE 1.00 24798.11 0.99 24929.36 0.98 25063.65 0.97 25200.97 0.96 25341.31 0.95 25484.67 0.94 25631.05 \\(\\alpha\\) MAPE 1.00 255.0456 0.99 257.5344 0.98 260.0311 0.97 262.5353 0.96 265.0464 0.95 267.5641 0.94 270.0878 \\(\\alpha\\) MAE 1.00 30.09061 0.99 30.21161 0.98 30.33493 0.97 30.46053 0.96 30.58839 0.95 30.71849 0.94 30.85080 Ragam minimum MSE dan MAE minimum saat alpha mendekati 1, sedangkan ragam MAPE minimum saat alpha mendekati 0.5. Bagaimana dengan performa di tiap iterasi? ggplot(resultSES,aes(x=iter,y=MSE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MSE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot untuk iterasi ke-9 (saat pandemi) dan ke-15 (pasca pandemi dan perang Rusia-Ukraina) memiliki rataan dan keragaman yang cukup besar dibandingkan iterasi lainnya pada data testing karena adanya fluktuasi yang ekstrem pada rentang waktu tersebut. Fluktuasi tersebut tidak cocok untuk SES karena kurang dapat menangani data dengan tren. ggplot(resultSES,aes(x=iter,y=MAPE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot untuk iterasi ke-15 ternyata tidak memiliki MAPE besar. Ini terjadi karena MAPE lebih memboboti observasi dengan nilai amatan kecil (COVID saat harga minyak turun) daripada saat nilai amatan besar (Ukraina-Rusia saat terjadi inflasi harga minyak). ggplot(resultSES,aes(x=iter,y=MAE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Boxplot MAE per iterasi secara umum lebih mengikuti MSE. Sama seperti SMA, nilai error homogen buruk di iterasi 9 dan 15. 3.6 DES Load fungsi: DESCV&lt;-fcCV(weeklyCrude[,3],initialn=36,folds=15,type=&quot;DES&quot;,alphrange=seq(0.1,1,0.1),betarange=seq(0.1,1,0.1)) Masukkan hasilnya: resultDES&lt;-DESCV[[3]] Karena parameter DES memiliki dua dimensi (alpha dan beta), cukup susah untuk menampilkan hasil optimalisasi parameter dalam suatu boxplot atau scatterplot. Oleh karena itu langsung buat agregasi: aggregateDES&lt;-resultDES[,`.`(meanMSE=mean(MSE), varMSE=var(MSE), meanMAPE=mean(MAPE), varMAPE=var(MAPE), meanMAE=mean(MAE), varMAE=var(MAE)), by=list(alphrange,betarange)] Buat heatmap untuk melihat titik mana memiliki rata-rata MSE yang rendah: ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = sqrt(meanMSE)), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Akar dari rata-rata MSE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap rerata MSE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Terlihat bahwa di beta lebih dari \\(0.1\\) rata-rata dari MSE relatif lebih besar. Bagaimana dengan ragam dari MSE (menggunakan skala log agar mudah dilihat). ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = log(varMSE)), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Log dari ragam MSE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap ragam MSE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Ragam dari MSE mengikuti rata-rata MSE. Di beta lebih dari 0.1, ragam MSE relatif besar. Tampak bahwa ragam MSE juga mengecil jika alpha mendekati 1. Bagaimana dengan MAPE? ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = meanMAPE), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Rata-rata MAPE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap rerata MAPE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Pola cukup mengikuti MSE sebelumnya, tetapi tampaknya MAPE minimum di alpha mendekati 0.5. Bagaimana dengan ragamnya: ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = sqrt(varMAPE)), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Akar dari ragam MAPE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap ragam MAPE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Ragam MAPE memiliki pola yang cukup beda. Ragam tersebut nampak minimum di diagonal antara Beta 0.5 dan alpha mendekati nol ke Beta 0.2 dan Alpha 0.25. Lakukan pemeringkatan: ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = meanMAE), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Rata-rata MAE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap rerata MAE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Mean dari MAE memiliki pola sama seperti sebelumnya. ggplot(aggregateDES, aes(alphrange, betarange)) + geom_tile(aes(fill = sqrt(varMAE)), colour = &quot;white&quot;) + scale_fill_gradient(&#39;Akar dari ragam MAE&#39;, low=&quot;#FFFFE0&quot;,high=&quot;#DB0000&quot;)+ ggtitle(&quot;Heatmap ragam MAE untuk tiap nilai alpha dan beta&quot;)+ theme_minimal()+theme(axis.title.y = element_text(angle = 0, vjust = 0.5))+ xlab(TeX(r&quot;($\\alpha$)&quot;))+ylab(TeX(r&quot;($\\beta$)&quot;)) Akar dari ragam MAE tampak minimum di diagonal dan di alpha 0.3 sampai 0.6. knitr::kables(list( knitr::kable(head(setorder(aggregateDES, meanMSE)[,c(1,2,3)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDES, meanMAPE)[,c(1,2,5)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDES, meanMAE)[,c(1,2,7)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ), caption=&quot;Rata-rata metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter.&quot; ) Table 3.7: Rata-rata metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter. \\(\\alpha\\) \\(\\beta\\) MSE 1.0 0.1 94.85663 0.9 0.1 97.46174 0.8 0.1 100.30364 0.7 0.1 103.28965 0.6 0.1 106.26093 \\(\\alpha\\) \\(\\beta\\) MAPE 1.0 0.1 13.01272 0.9 0.1 13.11358 0.8 0.1 13.22221 0.4 0.1 13.24879 0.5 0.1 13.28264 \\(\\alpha\\) \\(\\beta\\) MAE 0.4 0.1 6.918836 0.5 0.1 6.987916 0.3 0.1 6.996000 1.0 0.1 7.023870 0.9 0.1 7.031178 Nampak kombinasi alpha dan beta 0.4 dan 0.1 cukup baik dalam meminmumkan rataan error. Terlihat bahwa range alpha yang meminimumkan MSE dan MAPE kira kira 0.3 sampai 0.6. Pencarian lebih detail dapat dilakukan di daerah ini. knitr::kables(list( knitr::kable(head(setorder(aggregateDES, varMSE)[,c(1,2,4)],n=7), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDES, varMAPE)[,c(1,2,6)],n=7), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDES, varMAE)[,c(1,2,8)],n=7), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ), caption=&quot;Ragam metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter.&quot; ) Table 3.8: Ragam metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter. \\(\\alpha\\) \\(\\beta\\) MSE 1.0 0.1 19373.94 0.9 0.1 21052.12 0.8 0.1 23133.75 0.7 0.1 25768.44 0.6 0.1 29198.67 1.0 0.2 30823.88 0.5 0.1 33528.18 \\(\\alpha\\) \\(\\beta\\) MAPE 1.0 0.1 123.1107 0.9 0.1 137.1151 1.0 0.2 144.8069 0.8 0.1 154.0144 0.9 0.2 158.0809 0.7 0.1 169.9230 0.8 0.2 173.8135 \\(\\alpha\\) \\(\\beta\\) MAE 1.0 0.1 23.37971 0.9 0.1 25.02203 0.8 0.1 27.01915 1.0 0.2 28.18582 0.7 0.1 29.23953 1.0 0.4 29.90639 1.0 0.3 30.10881 Terlihat bahwa kriteria peminimuman ragam MSE dan MAPE berbeda dari peminimuman rata-rata MSE dan MAPE. Lakukan iterasi kedua untuk range \\(\\alpha\\ 0.3-0.6\\), \\(\\beta\\ 0.01-0.2\\): DESCV2&lt;-fcCV(weeklyCrude[,3],initialn=36,folds=15,type=&quot;DES&quot;,alphrange=seq(0.3,0.6,0.01),betarange=seq(0.01,0.2,0.01)) Masukkan hasilnya: resultDES2&lt;-DESCV2[[3]] Langsung lakukan agregasi: aggregateDES2&lt;-resultDES2[,`.`(meanMSE=mean(MSE), varMSE=var(MSE), meanMAPE=mean(MAPE), varMAPE=var(MAPE), meanMAE=mean(MAE), varMAE=var(MAE)), by=list(alphrange,betarange)] Nilai nilai apa saja yang menimumkan MSE, MAPE, dan MAE: knitr::kables(list( knitr::kable(head(setorder(aggregateDES2, meanMSE)[,c(1,2,3)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDES2, meanMAPE)[,c(1,2,5)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDES2, meanMAE)[,c(1,2,7)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ), caption=&quot;Rata-rata metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter.&quot; ) Table 3.9: Rata-rata metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter. \\(\\alpha\\) \\(\\beta\\) MSE 0.60 0.05 95.80204 0.60 0.06 95.92052 0.59 0.05 96.11010 0.59 0.06 96.20836 0.58 0.05 96.42100 \\(\\alpha\\) \\(\\beta\\) MAPE 0.60 0.08 13.04247 0.59 0.08 13.05033 0.58 0.08 13.05788 0.57 0.08 13.06533 0.56 0.08 13.07340 \\(\\alpha\\) \\(\\beta\\) MAE 0.60 0.07 6.787763 0.59 0.07 6.791494 0.58 0.07 6.795033 0.57 0.07 6.799216 0.51 0.08 6.803002 Dan ragamnya. knitr::kables(list( knitr::kable(head(setorder(aggregateDES2, varMSE)[,c(1,2,4)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDES2, varMAPE)[,c(1,2,6)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDES2, varMAE)[,c(1,2,8)],n=5), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ), caption=&quot;Ragam metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter.&quot; ) Table 3.10: Ragam metrik akurasi di semua iterasi untuk tiap kombinasi nilai parameter. \\(\\alpha\\) \\(\\beta\\) MSE 0.60 0.04 20781.43 0.59 0.04 21002.53 0.60 0.03 21168.86 0.58 0.04 21226.63 0.60 0.05 21339.40 \\(\\alpha\\) \\(\\beta\\) MAPE 0.60 0.13 177.0180 0.60 0.12 177.8438 0.60 0.14 178.0261 0.59 0.13 178.2966 0.59 0.12 179.1988 \\(\\alpha\\) \\(\\beta\\) MAE 0.60 0.05 26.95027 0.60 0.04 26.96540 0.59 0.05 27.14474 0.59 0.04 27.15655 0.58 0.05 27.34111 Plot iterasi mana yang susah: ggplot(resultDES,aes(x=iter,y=MAPE,group=iter))+ geom_boxplot(fill=&quot;#E69F00&quot;)+theme_minimal()+ ggtitle(&quot;Boxplot MAPE tiap Iterasi&quot;)+ xlab(&quot;Iterasi&quot;)+ylab(&quot; &quot;) Sama seperti sebelumnya, performa pemulusan buruk saat COVID. 3.7 Kesimpulan Suatu hasil peramalan dikatakan baik apabila nilai dari metode peramalannya mendekati data aktual serta memiliki tingkat kesalahan yang paling kecil. Untuk itu pemilihan metode terbaik dapat dipilih berdasarkan nilai MSE, MAPE, dan MAE. knitr::kables(list( knitr::kable(head(setorder(aggregateSMA, meanMSE)[,c(1,2)],n=1), col.names=c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateSMA, meanMAPE)[,c(1,4)],n=1), col.names=c(&quot;M&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateSMA, meanMAE)[,c(1,6)],n=1), col.names=c(&quot;M&quot;,&quot;MAE&quot;)) ),caption=&quot;SMA&quot; ) Table 3.11: SMA M MSE 2 108.067 M MAPE 2 14.6048 M MAE 2 7.290667 knitr::kables(list( knitr::kable(head(setorder(aggregateDMA, meanMSE)[,c(1,2)],n=1), col.names=c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDMA, meanMAPE)[,c(1,4)],n=1), col.names=c(&quot;M&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDMA, meanMAE)[,c(1,6)],n=1), col.names=c(&quot;M&quot;,&quot;MAE&quot;)) ),caption=&quot;DMA&quot; ) Table 3.11: DMA M MSE 11 118.3255 M MAPE 10 15.02806 M MAE 12 7.523578 knitr::kables(list( knitr::kable(head(setorder(aggregateSES, meanMSE)[,c(1,2)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateSES, meanMAPE)[,c(1,4)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateSES, meanMAE)[,c(1,6)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;MAE&quot;)) ),caption=&quot;SES&quot; ) Table 3.11: SES \\(\\alpha\\) MSE 1 94.34572 \\(\\alpha\\) MAPE 1 13.23114 \\(\\alpha\\) MAE 1 6.85325 knitr::kables(list( knitr::kable(head(setorder(aggregateDES2, meanMSE)[,c(1,2,3)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(aggregateDES2, meanMAPE)[,c(1,2,5)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAPE&quot;)), knitr::kable(head(setorder(aggregateDES2, meanMAE)[,c(1,2,7)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ),caption=&quot;DES&quot; ) Table 3.11: DES \\(\\alpha\\) \\(\\beta\\) MSE 0.6 0.05 95.80204 \\(\\alpha\\) \\(\\beta\\) MAPE 0.6 0.08 13.04247 \\(\\alpha\\) \\(\\beta\\) MAE 0.6 0.07 6.787763 Berdasarkan hasil di atas, dapat dilihat bahwa nilai ketepatan yang lebih kecil dibanding dengan metode lainnya adalah DES dengan nilai MSE = 116.593, MAPE = 14.82092. 3.8 Addendum: Last Block Tadi digunakan validasi silang untuk mengukur akurasi di berbagai kemungkinan data testing. Bagaimana jika data dianggap terganggu secara signifikan, dan hanya blok terakhir yang relevan? Ambil saja iterasi terakhir dari hasil validasi silang: lbSMA&lt;-resultSMA[,`.`(&quot;MSE&quot;=last(MSE), &quot;MAE&quot;=last(MAE), &quot;MAPE&quot;=last(MAPE)),by=list(M)] lbDMA&lt;-resultDMA[,`.`(&quot;MSE&quot;=last(MSE), &quot;MAE&quot;=last(MAE), &quot;MAPE&quot;=last(MAPE)),by=list(M)] lbSES&lt;-resultSES[,`.`(&quot;MSE&quot;=last(MSE), &quot;MAE&quot;=last(MAE), &quot;MAPE&quot;=last(MAPE)),by=list(alpha)] lbDES&lt;-resultDES[,`.`(&quot;MSE&quot;=last(MSE), &quot;MAE&quot;=last(MAE), &quot;MAPE&quot;=last(MAPE)),by=list(alphrange,betarange)] Lalu, cari saja nilai yang meminimumkan error: knitr::kables(list( knitr::kable(head(setorder(lbSMA, MSE)[,c(1,2)],n=1), col.names=c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(lbSMA, MAE)[,c(1,3)],n=1), col.names=c(&quot;M&quot;,&quot;MAE&quot;)) ),caption=&quot;SMA&quot; ) Table 3.12: SMA M MSE 13 541.1841 M MAE 13 20.66764 knitr::kables(list( knitr::kable(head(setorder(lbDMA, MSE)[,c(1,2)],n=1), col.names=c(&quot;M&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(lbDMA, MAE)[,c(1,3)],n=1), col.names=c(&quot;M&quot;,&quot;MAE&quot;)) ),caption=&quot;DMA&quot; ) Table 3.12: DMA M MSE 2 61.32953 M MAE 2 5.900313 knitr::kables(list( knitr::kable(head(setorder(lbSES, MSE)[,c(1,2)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(lbSES, MAE)[,c(1,3)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;MAE&quot;)) ),caption=&quot;SES&quot; ) Table 3.12: SES \\(\\alpha\\) MSE 1 591.3185 \\(\\alpha\\) MAE 1 21.84688 knitr::kables(list( knitr::kable(head(setorder(lbDES, MSE)[,c(1,2,3)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MSE&quot;)), knitr::kable(head(setorder(lbDES, MAE)[,c(1,2,5)],n=1), col.names=c(&quot;$\\\\alpha$&quot;,&quot;$\\\\beta$&quot;,&quot;MAE&quot;)) ),caption=&quot;DES&quot; ) Table 3.12: DES \\(\\alpha\\) \\(\\beta\\) MSE 0.6 1 58.09093 \\(\\alpha\\) \\(\\beta\\) MAE 0.6 1 5.772313 DES dengan \\(\\alpha=1\\) dan \\(\\beta=0.8-0.9\\) baik untuk data ini. Lakukan pemulusan: des1&lt;-esWrapper(weeklyCrude[,3][1:260], HoltWinters(weeklyCrude[,3][1:260],alpha=1,beta=0.8,gamma=F), 16) smooth&lt;- cbind(weeklyCrude,c(des1[[1]]$Smoothed,rep(NA,16)),c(rep(NA,260),des1[[2]]$forc)) Plot hasil pemulusan tersebut: ggplot(aes(x=Date,y=Close),data=smooth)+geom_point( size=2, alpha=.3, color=&quot;grey&quot;)+ geom_line(aes(y=V2,color=&quot;Pemulusan&quot;), ,size=0.5)+ geom_line(aes(y=V3, color=&quot;Prediksi&quot;),size=0.5)+ ylab(&quot;&quot;)+xlab(&quot;Waktu&quot;)+ ggtitle(TeX(r&#39;(Hasil pemulusan dan prediksi DES $\\alpha=1$, $\\beta=0.8$)&#39;))+ scale_color_manual(name=&#39;DES&#39;, breaks=c(&#39;Pemulusan&#39;, &#39;Prediksi&#39;), values=c(&#39;Pemulusan&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ theme_minimal() Atau, des2&lt;-esWrapper(weeklyCrude[,3][1:260], HoltWinters(weeklyCrude[,3][1:260],alpha=1,beta=0.9,gamma=F), 16) smooth&lt;- cbind(weeklyCrude,c(des2[[1]]$Smoothed,rep(NA,16)),c(rep(NA,260),des2[[2]]$forc)) Plot hasil pemulusan tersebut: ggplot(aes(x=Date,y=Close),data=smooth)+geom_point( size=2, alpha=.3, color=&quot;grey&quot;)+ geom_line(aes(y=V2,color=&quot;Pemulusan&quot;), ,size=0.5)+ geom_line(aes(y=V3, color=&quot;Prediksi&quot;),size=0.5)+ ylab(&quot;&quot;)+xlab(&quot;Waktu&quot;)+ ggtitle(TeX(r&#39;(Hasil pemulusan dan prediksi DES $\\alpha=1$, $\\beta=0.9$)&#39;))+ scale_color_manual(name=&#39;DES&#39;, breaks=c(&#39;Pemulusan&#39;, &#39;Prediksi&#39;), values=c(&#39;Pemulusan&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ theme_minimal() ## Warning: Removed 20 row(s) containing missing values (geom_path). ## Warning: Removed 262 row(s) containing missing values (geom_path). Plot hasil DMA: dma&lt;-dma.dt(weeklyCrude[,3][1:260],3,16) smooth&lt;- cbind(weeklyCrude,c(dma[[1]]$forc,rep(NA,16)),c(rep(NA,260),dma[[2]]$forc)) Plot hasil pemulusan tersebut: ggplot(aes(x=Date,y=Close),data=smooth)+geom_point( size=2, alpha=.3, color=&quot;grey&quot;)+ geom_line(aes(y=V2,color=&quot;Training&quot;), ,size=0.5)+ geom_line(aes(y=V3, color=&quot;Testing&quot;),size=0.5)+ ylab(&quot;&quot;)+xlab(&quot;Waktu&quot;)+ ggtitle(TeX(r&#39;(Hasil prediksi DMA $m=3$)&#39;))+ scale_color_manual(name=&#39;Prediksi DMA&#39;, breaks=c(&#39;Training&#39;, &#39;Testing&#39;), values=c(&#39;Training&#39;=&#39;black&#39;, &#39;Testing&#39;=&#39;#DB0000&#39;))+ theme_minimal() ## Warning: Removed 23 row(s) containing missing values (geom_path). ## Warning: Removed 262 row(s) containing missing values (geom_path). SMA? smar&lt;-sma.dt(weeklyCrude[,3][1:260],12,16) smooth&lt;- cbind(weeklyCrude,c(smar[[1]]$forc,rep(NA,16)),c(rep(NA,260),smar[[2]]$forc)) Plot hasil pemulusan tersebut: ggplot(aes(x=Date,y=Close),data=smooth)+geom_point( size=2, alpha=.3, color=&quot;grey&quot;)+ geom_line(aes(y=V2,color=&quot;Training&quot;), ,size=0.5)+ geom_line(aes(y=V3, color=&quot;Testing&quot;),size=0.5)+ ylab(&quot;&quot;)+xlab(&quot;Waktu&quot;)+ ggtitle(TeX(r&#39;(Hasil prediksi SMA $m=12$)&#39;))+ scale_color_manual(name=&#39;Prediksi SMA&#39;, breaks=c(&#39;Training&#39;, &#39;Testing&#39;), values=c(&#39;Training&#39;=&#39;black&#39;, &#39;Testing&#39;=&#39;#DB0000&#39;))+ theme_minimal() ## Warning: Removed 30 row(s) containing missing values (geom_path). ## Warning: Removed 262 row(s) containing missing values (geom_path). Forecast dari plot deret waktu tampak buruk. Note: SES(1) sama saja dengan menggunakan data yang paling recent, sehingga plot SES akan tampak relatif sama dengan SMA. References "],["analisis-intervensi-pada-model-arima.html", "Bab 4 Analisis Intervensi pada model ARIMA 4.1 Awal COVID 4.2 COVID rebuilding 4.3 Masa Sekarang", " Bab 4 Analisis Intervensi pada model ARIMA library(forecast) library(TSA) library(ggplot2) Akan dilakukan pemodelan di tiga periode: saat awal COVID, rebuilding setelah COVID pada akhir tahun 2020, dan masa sekarang 4.1 Awal COVID Secara umum metode pemulusan cukup buruk dalam meramal harga minyak saat COVID dan perang Rusia-Ukraina. Oleh karena itu, coba ambil data saat COVID terlebih dahulu. Jika dilihat dari tabel di bawah, harga minyak mulai turun pada minggu kesembilan 2020 (28 Februari 2020), dan tetap turun. Oleh karena itu, ambil dua titik data awal dari penurunan tersebut (28 Februari dan 06 Februari) untuk menandakan intervensi tersebut, lalu coba ramal titik-titik selanjutnya. knitr::kable(weeklyCrude[160:170]) Week Date Close Dist 6DW 8DW 2017 - Siklik Awal 2018 - harga naik Akhir 2018 - harga turun Pra-COVID COVID Pemulihan Vaksin, Varian 2022 2020-W04 2020-01-24 54.19 7 days 0 0 FALSE FALSE FALSE TRUE FALSE FALSE Lainnya Lainnya 2020-W05 2020-01-31 51.56 7 days 0 0 FALSE FALSE FALSE TRUE FALSE FALSE Lainnya Lainnya 2020-W06 2020-02-07 50.32 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W07 2020-02-14 52.05 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W08 2020-02-21 53.38 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W09 2020-02-28 44.76 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W10 2020-03-06 41.28 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W11 2020-03-13 31.73 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W12 2020-03-20 22.43 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W13 2020-03-27 21.51 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 2020-W14 2020-04-03 28.34 7 days 0 0 FALSE FALSE FALSE FALSE TRUE FALSE Lainnya Lainnya 4.1.1 ARIMA Ambil semua data sampai 6 Maret 2020 (observasi ke-166) sebagai data latih. Titik intervensi COVID yang diambil adalah 28 Februari (observasi ke-165). wcrude.covid&lt;-subset(weeklyCrude, Date&lt;=as.Date(&quot;2020-04-13&quot;)) wcrude.train&lt;-subset(wcrude.covid, Date&lt;=as.Date(&quot;2020-03-06&quot;)) 4.1.1.1 Cek Kestasioneran Data dan Identifikasi acf(wcrude.train$Close, main=&quot;ACF Harga Minyak pra-COVID&quot;) Dari plot time series yang dibuat saat eksplorasi telah ditunjukkan bahwa data tidak stasioner. Plot ACF tersebut juga menunjukkan bahwa data tidak stasioner karena pola turun secara perlahan. Untuk itu perlu dilakukan differencing: WCrude.covid_diff &lt;- diff(wcrude.train$Close, differences= 1) #Plot time series ts.plot(WCrude.covid_diff, main = &quot;First Difference Haarga Minyak pra-COVID&quot;, ylab = &quot; &quot;) Berdasarkan hasil plot time series dapat dilihat bahwa data telah stasioner pada suatu nilai tertentu. Namun, terlihat lonjakan di akhir sebagai efek dari COVID. Untuk memastikannya maka akan dilihat plot ACF: acf(WCrude.covid_diff, lag.max = 20, main = &quot;Plot ACF&quot;) pacf(WCrude.covid_diff, lag.max = 20, main = &quot;Plot PACF&quot;) Melalui plot ACF dan PACF dapat dilihat bahwa data sudah stasioner. Plot ACF dan PACF langsung cut off pada lag 1. Untuk memastikannya dapat dilakukan Uji Formal Augmented Dickey-Fuller Test sebagai berikut. Hipotesis: \\[ \\begin{aligned} H_0&amp;: \\text{ Data tidak stasioner}\\\\ H_1&amp;: \\text{ Data stasioner} \\end{aligned} \\] #ADF Test# aTSA::adf.test(WCrude.covid_diff) ## Augmented Dickey-Fuller Test ## alternative: stationary ## ## Type 1: no drift no trend ## lag ADF p.value ## [1,] 0 -11.57 0.01 ## [2,] 1 -8.47 0.01 ## [3,] 2 -6.75 0.01 ## [4,] 3 -6.32 0.01 ## [5,] 4 -5.18 0.01 ## Type 2: with drift no trend ## lag ADF p.value ## [1,] 0 -11.55 0.01 ## [2,] 1 -8.45 0.01 ## [3,] 2 -6.74 0.01 ## [4,] 3 -6.31 0.01 ## [5,] 4 -5.17 0.01 ## Type 3: with drift and trend ## lag ADF p.value ## [1,] 0 -11.61 0.01 ## [2,] 1 -8.53 0.01 ## [3,] 2 -6.81 0.01 ## [4,] 3 -6.39 0.01 ## [5,] 4 -5.26 0.01 ## ---- ## Note: in fact, p.value = 0.01 means p.value &lt;= 0.01 Karena nilai P-Value = 0.01 &lt; alpha = 0.05, maka tolak H0. Artinya model tersebut stasioner. eacf(WCrude.covid_diff) ## AR/MA ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 0 o o o o o o o o o o o x o o ## 1 x o o o o o o o o o o o o o ## 2 x o o o o o o o o o o o o o ## 3 x x x o o o o o o o o o o o ## 4 x x x o o o o o o o o o o o ## 5 o o o x o o o o o o o o o o ## 6 x o x x o o o o o o o o o o ## 7 o o o x o o o o o o o o o o Berdasarkan plot EACF tersebut, diperoleh dugaan model lainnya yaitu ARIMA (0,1,1), ARIMA (1,1,0), ARIMA(1,1,1),dan ARIMA(1,1,2). Sehingga setelah dilakukan spesifikasi, terdapat 4 model tentatif yang dapat diuji. 4.1.1.2 Pendugaan Parameter model1.Wcrude=Arima(wcrude.train$Close, order=c(0,1,1),method=&quot;ML&quot;) model2.Wcrude=Arima(wcrude.train$Close, order=c(1,1,0),method=&quot;ML&quot;) model3.Wcrude=Arima(wcrude.train$Close, order=c(1,1,1),method=&quot;ML&quot;) model4.Wcrude=Arima(wcrude.train$Close, order=c(1,1,2),method=&quot;ML&quot;) knitr::kable( cbind(c(&quot;ARIMA (0,1,1)&quot;,&quot;ARIMA (1,1,0)&quot;,&quot;ARIMA (1,1,1)&quot;,&quot;ARIMA (1,1,2)&quot;), c(model1.Wcrude$aic,model2.Wcrude$aic,model3.Wcrude$aic,model4.Wcrude$aic)), col.names=c(&quot;Model&quot;,&quot;AIC&quot;) ) Model AIC ARIMA (0,1,1) 749.922888182951 ARIMA (1,1,0) 750.006767863485 ARIMA (1,1,1) 748.606798472797 ARIMA (1,1,2) 750.35562990366 Model dengan AIC terkecil adalah \\(ARIMA(1,1,1)\\). Semua koefisiennya juga beda signifikan dari nol: lmtest::coeftest(model3.Wcrude) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 -0.878333 0.055168 -15.921 &lt; 2.2e-16 *** ## ma1 0.965463 0.030861 31.285 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 4.1.1.3 Diagnostik dan Forecasting covArima&lt;-Arima(wcrude.train$Close, order=c(1,1,1), method=&quot;ML&quot;) Diagnostik model sebenarnya cukup baik: checkresiduals(covArima) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,1) ## Q* = 5.0142, df = 8, p-value = 0.7561 ## ## Model df: 2. Total lags used: 10 Tapi prediksi model tidak sesuai dengan apa yang akan terjadi. Bandingkan prediksi untuk 2 minggu saja: forcdef&lt;-forecast(covArima,5) wcrude.covid[,`:=`(&quot;fitted.def&quot;=c(forcdef$fitted,rep(NA,5)), &quot;predicted.def&quot;=c(rep(NA,166),forcdef$mean), &quot;lwr.def&quot;=c(rep(NA,166),forcdef$lower[,2]), &quot;upr.def&quot;=c(rep(NA,166),forcdef$upper[,2]))] ggplot(aes(x=Date,y=Close),data=wcrude.covid[150:168])+ geom_point(size=3, alpha=0.3, color=&quot;gray&quot;)+ geom_line(aes(y=fitted.def,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Prediksi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Prediksi&quot;, fill=&quot;Prediksi&quot;),alpha=0.3)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Prediksi&#39;), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Prediksi&#39;), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ theme_minimal() ## Warning: Removed 2 row(s) containing missing values (geom_path). ## Warning: Removed 17 rows containing missing values (geom_point). Tentu prediksi tersebut cukup buruk. 4.1.2 Analisis intervensi Lakukan pemodelan ARIMAX (analisis intervensi) dengan sebuah fungsi transfer. Pada dasarnya kita akan membuat suatu peubah dummy pada 28 Februari 2020 untuk menandakan reaksi pasar terhadap COVID. Lalu akan dimodelkan dengan suatu fungsi (Cryer dan Chan 2008): \\[ m_t=\\frac{(\\theta_0+\\theta_1B+...+\\theta_{q-1}B^{q-1})}{(1-\\phi_1 B -...-\\phi_p B^p)} P_t \\] Dengan: \\[ \\begin{aligned} m_t&amp;=\\text{ Pengaruh intervensi (COVID) di waktu ke-t}\\\\ Z_t&amp;=\\begin{cases} 1, &amp; t=165 \\text{ (28 Februari 2020, mulai COVID)}\\\\ 0, &amp;\\text{lainnya}\\\\ \\end{cases}\\\\ \\end{aligned} \\] Salah satu model paling sederhana adalah dengan \\(AR(1)\\) - pada dasarnya model intervensi akan menjadi: \\[ \\begin{aligned} m_t&amp;=\\frac{\\theta_0}{(1-\\phi_1 B)} P_t\\\\ (1-\\phi_1B)m_t&amp;=\\theta_0P_t\\\\ m_t-\\phi_1m_{t-1}&amp;=\\theta_0P_t\\\\ m_t&amp;=\\theta_0P_t+\\phi_1m_{t-1} \\end{aligned} \\] Saat \\(P_{t}=1\\), tentu \\(P_{t-1}=0\\), \\(m_{t-2}=0\\) (intervensi belum memiliki efek). Oleh karena itu dapat dilihat bahwa di waktu intervensi ke-r: \\[ \\begin{aligned} m_r&amp;=\\theta_0\\\\ m_{r+1}&amp;=\\theta_0\\cdot0+\\phi_1m_{r}=\\phi_1\\theta_0\\\\ m_{r+2}&amp;=\\theta_0\\cdot0+\\phi_1m_{r+1}=\\phi_1^2\\theta_0\\\\ \\end{aligned} \\] Dan seterusnya. Saat \\(\\phi_1&lt;0\\), fungsi ini menandakan suatu efek yang lama-kelamaan mengalami decay. Coba modelkan fungsi yang ada dengan metode tersebut: intvmod&lt;-arimax(wcrude.train$Close, order=c(1,1,1), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train))==165)), transfer=list(c(1,0))) intvmod ## ## Call: ## arimax(x = wcrude.train$Close, order = c(1, 1, 1), xtransf = data.frame(COVID = 1 * ## (seq(nrow(wcrude.train)) == 165)), transfer = list(c(1, 0))) ## ## Coefficients: ## ar1 ma1 COVID-AR1 COVID-MA0 ## -0.8990 0.9625 1.5199 -7.9141 ## s.e. 0.0594 0.0388 0.3160 2.2452 ## ## sigma^2 estimated as 4.819: log likelihood = -363.99, aic = 735.98 Terlihat bahwa AIC model dengan intervensi lebih baik: knitr::kable( cbind(c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;), c(covArima$aic,intvmod$aic)), col.names=c(&quot;Model&quot;,&quot;AIC&quot;) ) Model AIC Tanpa Intervensi 748.606798472797 Intervensi 735.979604802578 Begitu juga akurasinya: compAcc&lt;-rbind(accuracy(covArima),accuracy(intvmod)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE MASE ACF1 Tanpa Intervensi -0.0744 2.2868 1.7466 -0.2395 3.1249 0.9709 0.0328 Intervensi -0.0054 2.1886 1.6826 -0.0829 2.9732 0.9354 0.0287 Diagnostik residual juga oke. Lonjakan karena COVID tidak muncul lagi: checkresiduals(intvmod) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,1) ## Q* = 5.8303, df = 6, p-value = 0.4425 ## ## Model df: 4. Total lags used: 10 Semua koefisien juga beda signifikan dari nol: lmtest::coeftest(intvmod) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 -0.899033 0.059366 -15.1438 &lt; 2.2e-16 *** ## ma1 0.962464 0.038829 24.7873 &lt; 2.2e-16 *** ## COVID-AR1 1.519897 0.316047 4.8091 1.516e-06 *** ## COVID-MA0 -7.914105 2.245154 -3.5250 0.0004235 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Nampaknya di term intervensi \\(AR(1)\\) merupakan model terbaik: arimax(wcrude.train$Close, order=c(1,1,1), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train))==165)), transfer=list(c(0,0))) ## ## Call: ## arimax(x = wcrude.train$Close, order = c(1, 1, 1), xtransf = data.frame(COVID = 1 * ## (seq(nrow(wcrude.train)) == 165)), transfer = list(c(0, 0))) ## ## Coefficients: ## ar1 ma1 COVID-MA0 ## -0.4994 0.6033 -2.5717 ## s.e. 0.5154 0.4752 1.5625 ## ## sigma^2 estimated as 5.273: log likelihood = -371.3, aic = 748.6 AIC model intervensi \\(MA(0)\\) lebih tinggi. Model intervensi lain tidak dapat diduga dengan informasi yang ada: arimax(wcrude.train$Close, order=c(1,1,1), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train))==165)), transfer=list(c(0,1))) ## Error in optim(init[mask], armaCSS, method = &quot;BFGS&quot;, hessian = FALSE, : initial value in &#39;vmmin&#39; is not finite arimax(wcrude.train$Close, order=c(1,1,1), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train))==165)), transfer=list(c(1,1))) ## Error in optim(init[mask], armaCSS, method = &quot;BFGS&quot;, hessian = FALSE, : initial value in &#39;vmmin&#39; is not finite 4.1.2.1 Forecasting Forecasting model intervensi ini cukup kompleks. Dapat digunakan fungsi filter di R untuk menduga efek dari intervensi tersebut: m.earlyCOV&lt;-stats::filter(1*(seq(nrow(wcrude.train)+5)==165), filter=1.5199, &quot;recursive&quot;)* -7.914 m.earlyCOV[165:171] ## [1] -7.91400 -12.02849 -18.28210 -27.78696 -42.23341 -64.19055 -97.56322 Ini dapat diverifikasi dengan manual: \\[ \\begin{aligned} m_r&amp;=-7.9141\\\\ m_{r+1}&amp;=\\phi_1\\theta_0=1.5199\\cdot -7.9141=-12.02864059\\\\ m_{r+2}&amp;=\\phi_1^2\\theta_0=1.5199^{2}\\cdot7.9141=-18.28233083\\\\ m_{r+3}&amp;=\\phi_1^3\\theta_0=1.5199^{3}\\cdot7.9141=-27.78731\\\\ \\end{aligned} \\] Lalu, hasil dari filter akan dimasukkan sebagai regressor di fungsi Arima yang dimiliki package forecast: intv.mod&lt;-Arima(wcrude.train$Close, order=c(1,1,1), xreg=m.earlyCOV[1:166]) intv.mod ## Series: wcrude.train$Close ## Regression with ARIMA(1,1,1) errors ## ## Coefficients: ## ar1 ma1 xreg ## -0.8992 0.9626 1.0000 ## s.e. 0.0592 0.0385 0.2538 ## ## sigma^2 = 4.908: log likelihood = -363.99 ## AIC=735.98 AICc=736.23 BIC=748.4 Terlihat bahwa koefisien COVID sama dengan satu. Ini pertanda baik, karena pada dasarnya kita membuat spesifikasi di mana koefisien dari regressor tersebut harus satu: \\[ Y_{t}=m_{t}+N_{t}= \\text{ efek intervensi}+ \\text{ ARIMA} \\] Sehingga sebenarnya akan diregresikan nilai-nilai \\(m_{t}\\) yang telah ditemukan saja. Lakukan forecast: forcinv&lt;-forecast(intv.mod,5,xreg=m.earlyCOV[167:171]) 4.1.3 Perbandingan Dan plot. Awalnya, duga sebanyak 2 periode saja: wcrude.covid[,`:=`(&quot;fitted.intv&quot;=c(forcinv$fitted,rep(NA,5)), &quot;predicted.intv&quot;=c(rep(NA,166),forcinv$mean), &quot;lwr.intv&quot;=c(rep(NA,166),forcinv$lower[,2]), &quot;upr.intv&quot;=c(rep(NA,166),forcinv$upper[,2]))] ggplot(aes(x=Date,y=Close),data=wcrude.covid[150:168])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intv,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.2)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.2)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ theme_minimal()+ylab(&quot; &quot;)+ ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) Namun, model ini tidak cocok untuk peramalan jangka panjang. Jika dilakukan peramalan dengan durasi sebulan (4 minggu), dugaan akan sangat jauh dari aktual. Fakta ini dapat dilihat dari plot: wcrude.covid[,`:=`(&quot;fitted.intv&quot;=c(forcinv$fitted,rep(NA,5)), &quot;predicted.intv&quot;=c(rep(NA,166),forcinv$mean), &quot;lwr.intv&quot;=c(rep(NA,166),forcinv$lower[,2]), &quot;upr.intv&quot;=c(rep(NA,166),forcinv$upper[,2]))] ggplot(aes(x=Date,y=Close),data=wcrude.covid[150:170])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intv,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.2)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.2)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ theme_minimal()+ylab(&quot; &quot;)+ ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) Ini terjadi karena kita tidak mengetahui cerita dari intervensi tersebut secara sepenuhnya. Terakhir, bandingkan error testing, pertama untuk prediksi dua periode ke depan: compAcc&lt;-rbind(accuracy(wcrude.covid$Close[1:168], wcrude.covid$predicted.def[1:168]), accuracy(wcrude.covid$Close[1:168], wcrude.covid$predicted.intv[1:168])) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 13.9157 14.7441 13.9157 33.8807 33.8807 Intervensi 2.8801 2.8843 2.8801 9.9138 9.9138 Dan untuk lima periode ke depan: compAcc&lt;-rbind(accuracy(wcrude.covid$Close, wcrude.covid$predicted.def), accuracy(wcrude.covid$Close, wcrude.covid$predicted.intv)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 15.6177 16.1276 15.6177 38.1101 38.1101 Intervensi -22.4012 35.3207 24.7053 84.9935 126.4934 Jelas bahwa secara jangka pendek (dua minggu), model dengan intervensi lebih baik daripada model tanpa intervensi. Namun, model tidak tepat digunakan untuk prediksi jauh ke depan. 4.2 COVID rebuilding Analisis intervensi juga berguna untuk pemodelan data setelah efek intervensi habis, misal saat harga minyak naik kembali setelah COVID. Ambil data sampai akhir 2020: wcrude.rebuild1&lt;-subset(weeklyCrude,Date&lt;=as.Date(&quot;2020-12-31&quot;)) Plot data tersebut: ggplot(aes(x=Date,y=Close),data=wcrude.rebuild1[160:209,])+ geom_point(size=3, alpha=0.6, color=&quot;gray&quot;)+theme_minimal() Ambil data sapai Juni 2020 sebagai data latih. Secara umum, rebuilding terjadi setelah harga sangat rendah di sekitar Mei 2020, sehingga saat Juni 2020 sudah terjadi sedikit kenaikan harga minyak: wcrude.train2&lt;-subset(weeklyCrude,Date&lt;=as.Date(&quot;2020-05-21&quot;)) Data tersebut jelas belum stasioner: acf(wcrude.train2$Close, main= &quot;ACF harga minyak sebelum COVID rebuilding&quot;) Maka lakukan differencing: difftrainreb&lt;-diff(wcrude.train2$Close,1) aTSA::adf.test(difftrainreb) ## Augmented Dickey-Fuller Test ## alternative: stationary ## ## Type 1: no drift no trend ## lag ADF p.value ## [1,] 0 -10.73 0.01 ## [2,] 1 -8.33 0.01 ## [3,] 2 -6.72 0.01 ## [4,] 3 -6.12 0.01 ## [5,] 4 -5.16 0.01 ## Type 2: with drift no trend ## lag ADF p.value ## [1,] 0 -10.72 0.01 ## [2,] 1 -8.32 0.01 ## [3,] 2 -6.72 0.01 ## [4,] 3 -6.13 0.01 ## [5,] 4 -5.17 0.01 ## Type 3: with drift and trend ## lag ADF p.value ## [1,] 0 -10.79 0.01 ## [2,] 1 -8.41 0.01 ## [3,] 2 -6.81 0.01 ## [4,] 3 -6.24 0.01 ## [5,] 4 -5.27 0.01 ## ---- ## Note: in fact, p.value = 0.01 means p.value &lt;= 0.01 Data sudah stasioner. Lalu identifikasi kandidat model: acf(difftrainreb) pacf(difftrainreb) Baik ACF dan PACF signifikan di lag pertama lalu cut off. EACF: eacf(difftrainreb) ## AR/MA ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 0 x o o o o o o o o o o o o o ## 1 o o o o o o o o o o o o o o ## 2 x o o o o o o o o o o o o o ## 3 x x o o o o o o o o o o o o ## 4 x o x x o o o o o o o o o o ## 5 x x x x x o o o o o o o o o ## 6 o o x x x o o o o o o o o o ## 7 x o x x o x o o o o o o o o Kandidat model adalah \\(ARIMA(1,1,0)\\), \\(ARIMA(0,1,1)\\), \\(ARIMA(2,1,1)\\), dan \\(ARIMA(1,1,1)\\) : rmod1&lt;-Arima(wcrude.train2$Close,order=c(1,1,0)) rmod2&lt;-Arima(wcrude.train2$Close,order=c(0,1,1)) rmod3&lt;-Arima(wcrude.train2$Close,order=c(2,1,1)) rmod4&lt;-Arima(wcrude.train2$Close,order=c(1,1,1)) knitr::kable( cbind(c(&quot;ARIMA (1,1,0)&quot;,&quot;ARIMA (0,1,1)&quot;,&quot;ARIMA (2,1,1)&quot;,&quot;ARIMA (1,1,1)&quot;), c(rmod1$aic,rmod2$aic,rmod3$aic,rmod4$aic)), col.names=c(&quot;Model&quot;,&quot;AIC&quot;) ) Model AIC ARIMA (1,1,0) 835.224348584948 ARIMA (0,1,1) 835.105820733153 ARIMA (2,1,1) 834.243852521724 ARIMA (1,1,1) 837.102045165476 Menunjukkan bahwa Arima(2,1,1) model terbaik dengan semua koefisien signifikan di taraf \\(10/%\\): lmtest::coeftest(rmod3) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 -0.748382 0.078214 -9.5684 &lt; 2e-16 *** ## ar2 0.135859 0.077041 1.7635 0.07782 . ## ma1 0.982464 0.020786 47.2667 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Tetap saja ada lonjakan besar di residual saat COVID: checkresiduals(rmod3) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(2,1,1) ## Q* = 6.5065, df = 7, p-value = 0.482 ## ## Model df: 3. Total lags used: 10 Intinya setelah dicoba \\(ARIMA(0,1,1)\\) oke: Tren naik kembali tidak dapat diprediksi. forcdef.reb&lt;-forecast(rmod3,33) wcrude.rebuild1[,`:=`(&quot;fitted.def&quot;=c(forcdef.reb$fitted,rep(NA,33)), &quot;predicted.def&quot;=c(rep(NA,176),forcdef.reb$mean), &quot;lwr.def&quot;=c(rep(NA,176),forcdef.reb$lower[,2]), &quot;upr.def&quot;=c(rep(NA,176),forcdef.reb$upper[,2]))] ggplot(aes(x=Date,y=Close),data=wcrude.rebuild1[150:185])+ geom_point(size=3, alpha=0.3, color=&quot;gray&quot;)+ geom_line(aes(y=fitted.def,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Prediksi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Prediksi&quot;, fill=&quot;Prediksi&quot;),alpha=0.3)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Prediksi&#39;), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ theme_minimal() ## Warning: Removed 9 row(s) containing missing values (geom_path). ## Warning: Removed 27 rows containing missing values (geom_point). Dapat dicoba berbagai spesifikasi model arimax. Pertama akan dicobakan spesifikasi arimax sebelumnya, yaitu AR saja. Koefisien MA lalu ditingkatkan sampai 3, lalu dicobakan cara (Cryer dan Chan 2008), yaitu membuat dua peubah untuk memisahkan efek langsung dari COVID dan efek yang secara eksponen turun. Efek langsung dimodelkan dengan MA dan efek turun dimodelkan dengan AR. Efek yang lebih kompleks untuk intervensi hanya dapat dimodelkan dengan \\(ARIMA(1,1,0)\\) untuk kesluruhan, tetapi ini tidak apa-apa karena model tersebut sebenarnya memiliki AIC yang mendekati \\(ARIMA(2,1,1)\\): arimaxdef&lt;-arimax(wcrude.train2$Close,order=c(2,1,1), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(1,0))) arimaxmad1&lt;-arimax(wcrude.train2$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(1,1))) arimaxmad2&lt;-arimax(wcrude.train2$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(1,2))) arimaxmad3&lt;-arimax(wcrude.train2$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(1,3))) arimaxd1&lt;-arimax(wcrude.train2$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165), COVIDb=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(0,1),c(1,0))) arimaxd2&lt;-arimax(wcrude.train2$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(wcrude.train2))==165), COVIDb=1*(seq(nrow(wcrude.train2))==165)), transfer=list(c(0,2),c(1,0))) Bandingkan AIC tiap spesifikasi model tersebut: knitr::kables(list( knitr::kable(arimaxdef$aic,col.names=&quot;Intervensi AR(1)&quot;), knitr::kable(cbind(arimaxmad1$aic,arimaxmad2$aic,arimaxmad3$aic), col.names=c(&quot;ARMA(1,1)&quot;,&quot;ARMA(1,2)&quot;,&quot;MA(1,3)&quot;)), knitr::kable(cbind(arimaxd1$aic,arimaxd2$aic),col.names=c(&quot;MA(1)+AR(1)&quot;,&quot;MA(2)+AR(1)&quot;)) ) ) Intervensi AR(1) 829.1429 ARMA(1,1) ARMA(1,2) MA(1,3) 829.9415 827.1838 794.4952 MA(1)+AR(1) MA(2)+AR(1) 816.3303 798.1868 Sehingga model terbaik adalah: lmtest::coeftest(arimaxmad3) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.085736 0.076698 1.1178 0.2636356 ## COVID-AR1 0.960466 0.024310 39.5084 &lt; 2.2e-16 *** ## COVID-MA0 -8.471105 2.348759 -3.6066 0.0003102 *** ## COVID-MA1 -4.447146 2.369339 -1.8770 0.0605241 . ## COVID-MA2 -10.611313 2.375934 -4.4662 7.963e-06 *** ## COVID-MA3 -10.643718 2.382815 -4.4669 7.937e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Terlihat bahwa semua koefisien lebih besar dari galat baku, sehingga kemungkinan signifikan.Signifikansi koefisien \\(AR(1)\\) cukup worrying, tetapi probabilitas koefisien tersebut muncul jika koefisiennya sebenarnya nol masih sekitar \\(26/%\\). Residual kedua model tampak oke: checkresiduals(arimaxmad3) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,0) ## Q* = 5.5843, df = 4, p-value = 0.2324 ## ## Model df: 6. Total lags used: 10 Perhatikan spesifikasi model tersebut secara matematis: \\[ \\begin{aligned} m_t&amp;=\\frac{(\\theta_0+\\theta_1B+\\theta_2B^2+\\theta_3B^3)}{(1-\\phi_1 B)} P_t\\\\ (1-\\phi_1B)m_t&amp;=\\theta_0P_t+\\theta_1P_{t-1}+\\theta_2P_{t-2}+\\theta_3P_{t-3}\\\\ m_t-\\phi_1m_{t-1}&amp;=\\theta_0P_t+\\theta_1P_{t-1}+\\theta_2P_{t-2}+\\theta_3P_{t-3}\\\\ m_t&amp;=\\theta_0P_t+\\theta_1P_{t-1}+\\theta_2P_{t-2}+\\theta_3P_{t-3}+\\phi_1m_{t-1}\\\\ \\end{aligned} \\] Sama seperti sebelumnya, untuk forecasting nilai tersebut dapat dicari dengan fungsi filter: COVID=1*(seq(nrow(wcrude.rebuild1))==165) tss&lt;-stats::filter(COVID,c(-8.471105, -4.447146, -10.611313, -10.643718),&quot;convolution&quot;,sides=1) tss[is.na(tss)]&lt;-0 m&lt;-stats::filter(tss,0.960466,&quot;recursive&quot;,sides=1) m[165:209] ## [1] -8.471105 -12.583354 -22.697197 -32.443604 -31.160979 -29.929060 -28.745845 -27.609407 ## [9] -26.517896 -25.469538 -24.462625 -23.495520 -22.566648 -21.674498 -20.817618 -19.994615 ## [17] -19.204148 -18.444931 -17.715729 -17.015355 -16.342670 -15.696579 -15.076031 -14.480015 ## [25] -13.907562 -13.357740 -12.829655 -12.322448 -11.835292 -11.367396 -10.917997 -10.486365 ## [33] -10.071797 -9.673619 -9.291182 -8.923864 -8.571068 -8.232220 -7.906767 -7.594181 ## [41] -7.293953 -7.005593 -6.728634 -6.462624 -6.207131 Empat hasil hitungan pertama mirip dengan hitungan manual. Selanjutnya dapat dengan mudah diverifikasi dengan mengalikan dengan pangkat dari \\(\\phi_1\\). \\[ \\begin{aligned} m_{r}&amp;=\\theta_0&amp;&amp;=-8.4711 \\\\ m_{r+1}&amp;=\\theta_1+\\phi_1\\theta_0&amp;=-4.4471+0.9605 \\cdot -8.4711&amp;=12.5835\\\\ m_{r+2}&amp;=\\theta_2+\\phi_1m_{r+1}=\\theta_2+\\phi_1\\theta_1+\\phi_1^2\\theta_0&amp;=-10.6113+0.9605\\cdot12.5835&amp;=22.69775175\\\\ m_{r+3}&amp;=\\theta_3+\\phi_1m_{r+2}=\\theta_3+\\phi_1\\theta_2+\\phi_1^2\\theta_1+\\phi_1^3\\theta_0&amp;=-10.6437+0.9605\\cdot22.69775175&amp;=32.44489057\\\\ m_{r+k}&amp;=\\phi_1^{k-3}m_{r+k-1}=\\phi_1^{k-3}\\theta_3+\\phi_1^{k-2}\\theta_2+\\phi_1^{k-1}\\theta_1+\\phi_1^k\\theta_0\\\\ \\end{aligned} \\] (0.9605^(1:20))*-32.44489057 ## [1] -31.16332 -29.93237 -28.75004 -27.61441 -26.52364 -25.47596 -24.46966 -23.50311 -22.57473 ## [10] -21.68303 -20.82655 -20.00390 -19.21375 -18.45481 -17.72584 -17.02567 -16.35316 -15.70721 ## [19] -15.08677 -14.49084 Gunakan fungsi Arima lalu prediksi: rebuildModfin&lt;-Arima(wcrude.train2$Close,order=c(1,1,0), xreg=m[1:176]) rebuildModfin ## Series: wcrude.train2$Close ## Regression with ARIMA(1,1,0) errors ## ## Coefficients: ## ar1 xreg ## 0.0850 0.9505 ## s.e. 0.0758 0.1424 ## ## sigma^2 = 5.519: log likelihood = -396.78 ## AIC=799.57 AICc=799.71 BIC=809.06 forc.inv.reb&lt;-forecast(rebuildModfin,33,xreg=m[177:209]) Dalam periode sama, dapat dilihat bahwa prediksi model ARIMAX lebih baik: wcrude.rebuild1[,`:=`(&quot;fitted.intv&quot;=c(forc.inv.reb$fitted,rep(NA,33)), &quot;predicted.intv&quot;=c(rep(NA,176),forc.inv.reb$mean), &quot;lwr.intv&quot;=c(rep(NA,176),forc.inv.reb$lower[,2]), &quot;upr.intv&quot;=c(rep(NA,176),forc.inv.reb$upper[,2]))] ggplot(aes(x=Date,y=Close),data=wcrude.rebuild1[150:185])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intv,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.1)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.1)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ theme_minimal()+ylab(&quot; &quot;)+ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) Bahkan, jika diekspansi sampai akhir 2020, prediksi masih baik. ggplot(aes(x=Date,y=Close),data=wcrude.rebuild1[150:209])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intv,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.1)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.1)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ theme_minimal()+ylab(&quot; &quot;)+ ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) Dapat dibandingkan akurasi di training: compAcc&lt;-rbind(accuracy(rmod3),accuracy(arimaxmad3)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable(compAcc,row.names=T,digits =4) ME RMSE MAE MPE MAPE MASE ACF1 Tanpa Intervensi -0.1080 2.5517 1.9351 -0.4137 4.0592 0.9751 -0.0061 Intervensi 0.0008 2.3463 1.8217 -0.1753 3.7110 0.9179 0.0016 Peramalan 9 periode: compAcc.1&lt;-rbind(accuracy(wcrude.rebuild1$Close[1:185], wcrude.rebuild1$predicted.def[1:185]), accuracy(wcrude.rebuild1$Close[1:185], wcrude.rebuild1$predicted.intv[1:185])) rownames(compAcc.1)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable(compAcc.1,row.names=T,digits =4) ME RMSE MAE MPE MAPE Tanpa Intervensi -7.7723 8.1563 7.7723 -25.4596 25.4596 Intervensi -4.5300 4.7263 4.5300 -13.4199 13.4199 Peramalan 33 periode: compAcc.2&lt;-rbind(accuracy(wcrude.rebuild1$Close[1:209], wcrude.rebuild1$predicted.def[1:209]), accuracy(wcrude.rebuild1$Close[1:209], wcrude.rebuild1$predicted.intv[1:209])) rownames(compAcc.2)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable(compAcc.1,row.names=T,digits =4) ME RMSE MAE MPE MAPE Tanpa Intervensi -7.7723 8.1563 7.7723 -25.4596 25.4596 Intervensi -4.5300 4.7263 4.5300 -13.4199 13.4199 Model dengan intervensi umumnya lebih baik. 4.3 Masa Sekarang Perang Ukraina Rusia dimulai di Februari 24, 2020. Ambil data ke 269 dan 270 (awal Maret), lalu prediksi harga minyak sampai akhir. weeklyCrude[269:277] ## Week Date Close Dist 6DW 8DW 2017 - Siklik Awal 2018 - harga naik ## 1: 2022-W08 2022-02-25 91.59 7 days 0 0 FALSE FALSE ## 2: 2022-W09 2022-03-04 115.68 7 days 0 0 FALSE FALSE ## 3: 2022-W10 2022-03-11 109.33 7 days 0 0 FALSE FALSE ## 4: 2022-W11 2022-03-18 104.70 7 days 0 0 FALSE FALSE ## 5: 2022-W12 2022-03-25 113.90 7 days 0 0 FALSE FALSE ## 6: 2022-W13 2022-04-01 99.27 7 days 0 0 FALSE FALSE ## 7: 2022-W14 2022-04-08 98.26 7 days 0 0 FALSE FALSE ## 8: 2022-W15 2022-04-14 106.95 6 days 1 0 FALSE FALSE ## 9: 2022-W16 2022-04-22 102.07 8 days 0 1 FALSE FALSE ## Akhir 2018 - harga turun Pra-COVID COVID Pemulihan Vaksin, Varian 2022 ## 1: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 2: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 3: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 4: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 5: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 6: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 7: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 8: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia ## 9: FALSE FALSE FALSE FALSE Lainnya Perang Ukraina-Russia crude.ukr&lt;-subset(weeklyCrude, Date&lt;=as.Date(&quot;2022-03-04&quot;)) 4.3.1 ARIMA 4.3.1.1 Cek Kestasioneran Data acf(crude.ukr$Close) Model tersebut tidak stasioner karena pola ACF tersebut turun secara perlahan. jadi diperlukan differencing untuk mengatasinya. crudeoil_diff &lt;- diff(crude.ukr$Close, differences= 1) ts.plot(crudeoil_diff) Hasil differencing menunjukkan pola data yang stasioner dengan nilai rataan tertentu, tetapi saat COVID dan di akhir (Rusia-Ukraina) terjadi gejolak. Cek kembali dengan plot ACF. acf(crudeoil_diff) pacf(crudeoil_diff) Plot ACF dan PACF langsung cut off setelah lag 0. Tetapi, untuk tetap mendapatkan pendugaan parameter, diduga plot crude oil tersebut mengikuti pola ARIMA(0,1,1) atah ARIMA(1,1,0). eacf(crudeoil_diff) ## AR/MA ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 0 x o o o o o o o o o o o o o ## 1 o o o o o o o o o o o o o o ## 2 o x o o o o o o o o o o o o ## 3 x x x o o o o o o o o o o o ## 4 o o x o o o o o o o o x o o ## 5 x o x o o o o o o o o o o o ## 6 x o o o x o o o o o o o o o ## 7 x x o o x x o o o o o o o o Plot EACF menghasilkan berbagai model tentatif, model tersebut adalah ARIMA(0,1,1), ARIMA(1,1,1), ARIMA(2,0,1), dan ARIMA(0,1,3). Lalu, dugalah parameter dari setiap model untuk mendapatkan model terbaik. 4.3.1.2 Pendugaan Parameter model1.crude1=Arima(crude.ukr$Close, order=c(0,1,1),method=&quot;ML&quot;) model1.crude2=Arima(crude.ukr$Close, order=c(1,1,0),method=&quot;ML&quot;) model1.crude3=Arima(crude.ukr$Close, order=c(1,1,1),method=&quot;ML&quot;) model1.crude4=Arima(crude.ukr$Close, order=c(2,1,1),method=&quot;ML&quot;) model1.crude5=Arima(crude.ukr$Close, order=c(0,1,3),method=&quot;ML&quot;) knitr::kable( cbind(c(&quot;ARIMA (0,1,1)&quot;,&quot;ARIMA (1,1,0)&quot;,&quot;ARIMA (1,1,1)&quot;,&quot;ARIMA (2,1,1)&quot;,&quot;ARIMA (0,1,3)&quot;), c(model1.crude1$aic,model1.crude2$aic,model1.crude3$aic,model1.crude4$aic, model1.crude5$aic)), col.names=c(&quot;Model&quot;,&quot;AIC&quot;) ) Model AIC ARIMA (0,1,1) 1360.03873997845 ARIMA (1,1,0) 1359.95557059779 ARIMA (1,1,1) 1361.95663763495 ARIMA (2,1,1) 1363.91268743951 ARIMA (0,1,3) 1363.64651734283 Model terbaik berdasarkan AIC: \\(ARIMA(1,1,1)\\). Semua koefisiennya signifikan: lmtest::coeftest(model1.crude3) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.152885 0.706776 0.2163 0.8287 ## ma1 0.026803 0.721648 0.0371 0.9704 4.3.1.3 Diagnostik Sisaan ARIMA(1,1,0) checkresiduals(model1.crude3) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,1) ## Q* = 6.008, df = 8, p-value = 0.6463 ## ## Model df: 2. Total lags used: 10 Terlihat bahwa semua diagnostik baik, kecuali sisaan tak normal karena ada beberapa amatan berpengaruh (Ukraina dan COVID). Untuk mengetahui kenormalan sisaan, terdapat 2 cara, yaitu secara eksploratif melalui Q-Q Plot, plot sisaan, plot ACF, dan plot PACF dan uji formal seperti Kolmogorov-Smirnov Test, Ljung Box Test, dan T-test. sisaan.crude &lt;- model1.crude2$residuals par(mfrow=c(2,2)) qqnorm(sisaan.crude) qqline(sisaan.crude, col = &quot;blue&quot;, lwd = 2) plot(c(1:length(sisaan.crude)),sisaan.crude) acf(sisaan.crude) pacf(sisaan.crude) Secara eksploratif, baik plot Q-Q dan sisaan terdapat pencilan di beberapa data yang membuat sisaan tersebut cenderung tidak mengikuti sebaran normal. Untuk memastikan apakah sebaran sisaan normal, perlu untuk dilakukan uji formal. ks.test(sisaan.crude,&quot;pnorm&quot;) ## ## One-sample Kolmogorov-Smirnov test ## ## data: sisaan.crude ## D = 0.22341, p-value = 3.939e-12 ## alternative hypothesis: two-sided Box.test(sisaan.crude, type = &quot;Ljung&quot;) ## ## Box-Ljung test ## ## data: sisaan.crude ## X-squared = 0.0012917, df = 1, p-value = 0.9713 t.test(sisaan.crude, mu = 0, conf.level = 0.95) ## ## One Sample t-test ## ## data: sisaan.crude ## t = 1.116, df = 269, p-value = 0.2654 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -0.1557737 0.5634570 ## sample estimates: ## mean of x ## 0.2038416 4.3.1.4 Forecasting Ramalan model tersebut sebagai berikut (walaupun sebenarnya kurang tepat meramal dengan model diagnostik kurang baik): forcdefukr&lt;-forecast(model1.crude2,7) weeklyCrude[,`:=`(&quot;fitted.def&quot;=c(forcdefukr$fitted,rep(NA,8)), &quot;predicted.def&quot;=c(rep(NA,271),forcdefukr$mean), &quot;lwr.def&quot;=c(rep(NA,271),forcdefukr$lower[,2]), &quot;upr.def&quot;=c(rep(NA,271),forcdefukr$upper[,2]))] ggplot(aes(x=Date,y=Close),data=weeklyCrude[260:277])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.def,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Prediksi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Prediksi&quot;, fill=&quot;Prediksi&quot;),alpha=0.2)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Prediksi&#39;), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Prediksi&#39;), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Prediksi&#39;=&#39;#DB0000&#39;))+ theme_minimal()+ylab(&quot; &quot;) ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, which will replace ## the existing scale. 4.3.2 ARIMAX Prediksi tersebut cukup tinggi. Bagaimana dengan model ARIMAX - akan ditambahkan peubah dummy untuk COVID dan Ukraina. Sebenarnya bisa saja dimodelkan hal seperti vaksinasi, varian Delta, dan Omicron, tetapi agar model tetap sederhana model dua hal itu saja. Untuk spesifikasi dummy Ukraina, akan diuji \\(MA(0)\\) - kenaikan intersep, \\(MA(1)\\), \\(AR(1)\\), dan \\(ARMA(1)\\): ukrmax1&lt;-arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), transfer=list(c(1,3),c(0,0))) ukrmax2&lt;-arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), transfer=list(c(1,3),c(0,1))) ukrmax3&lt;-arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), transfer=list(c(1,3),c(1,0))) ukrmax4&lt;-arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), transfer=list(c(1,3),c(1,1))) Bandingkan AIC tiap spesifikasi tersebut: knitr::kable(cbind(ukrmax1$aic, ukrmax2$aic, ukrmax3$aic, ukrmax4$aic), col.names=c(&quot;MA(0)&quot;,&quot;MA(1)&quot;,&quot;AR(1)&quot;, &quot;ARMA(1,1)&quot;)) MA(0) MA(1) AR(1) ARMA(1,1) 1301.586 1258.96 1253.242 1288.709 Terlihat bahwa spesifikasi AR(1) atau MA(1) baik: lmtest::coeftest(ukrmax2) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.0630424 0.0619903 1.0170 0.309167 ## COVID-AR1 0.9131724 0.0031859 286.6304 &lt; 2.2e-16 *** ## COVID-MA0 -7.9050997 2.4722178 -3.1976 0.001386 ** ## COVID-MA1 -3.1209729 2.4942996 -1.2512 0.210846 ## COVID-MA2 -13.2774945 2.5025092 -5.3057 1.123e-07 *** ## COVID-MA3 -13.5402925 2.4858155 -5.4470 5.122e-08 *** ## UR-MA0 -2.7845351 2.5369932 -1.0976 0.272391 ## UR-MA1 23.2988355 3.6560972 6.3726 1.859e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 lmtest::coeftest(ukrmax3) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.1214257 0.0623438 1.9477 0.0514535 . ## COVID-AR1 0.9639880 0.0034178 282.0488 &lt; 2.2e-16 *** ## COVID-MA0 -7.5840609 2.4970764 -3.0372 0.0023881 ** ## COVID-MA1 -2.7376270 2.5313652 -1.0815 0.2794826 ## COVID-MA2 -9.2578375 2.5230528 -3.6693 0.0002432 *** ## COVID-MA3 -9.8727174 2.4939425 -3.9587 7.537e-05 *** ## UR-AR1 -5.3896474 2.2713904 -2.3728 0.0176519 * ## UR-MA0 -3.5540212 1.2254026 -2.9003 0.0037282 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Tampaknya lebih banyak koefisien signifikan di spesifikasi AR, tapi kita harus pikirkan implikasi dari memilih model tersebut. Efek awal perang sebesar \\(-3.55\\). Lalu dikalikan \\(-5.389\\) menjadi sekitar 15. Lalu dikalikan lagi menjadi sekitar \\(-75\\). Dugaan tersebut tentu sangat aneh - harga berflukutasi plus-minus sangat besar. Uji residual model tersebut. checkresiduals(ukrmax2) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,0) ## Q* = 17.012, df = 3, p-value = 0.0007028 ## ## Model df: 8. Total lags used: 11 checkresiduals(ukrmax3) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,0) ## Q* = 14.116, df = 3, p-value = 0.002752 ## ## Model df: 8. Total lags used: 11 Spesifikasi intervensi \\(AR(1)\\) lebih baik dalam uji Ljung-Box. Namun, kedua spesifikasi berhasil mengatasi masalah non-normaltas. Walaupun begitu, akan tetap diambil spesifikasi \\(MA(1)\\) karena ramalan spesifikasi intervensi \\(AR(1)\\) akan aneh. arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), fixed=c(NA,NA,NA,NA,NA,NA,0,NA), transfer=list(c(1,3),c(0,1))) ## ## Call: ## arimax(x = crude.ukr$Close, order = c(1, 1, 0), fixed = c(NA, NA, NA, NA, NA, ## NA, 0, NA), xtransf = data.frame(COVID = 1 * (seq(nrow(crude.ukr)) == 165), ## UR = 1 * (seq(nrow(crude.ukr)) == 269)), transfer = list(c(1, 3), c(0, 1))) ## ## Coefficients: ## ar1 COVID-AR1 COVID-MA0 COVID-MA1 COVID-MA2 COVID-MA3 UR-MA0 UR-MA1 ## 0.1120 0.8776 -7.7107 -3.6061 -9.6746 -10.0563 0 24.1401 ## s.e. 0.0611 0.0085 2.4211 2.4530 2.4534 2.4282 0 2.4834 ## ## sigma^2 estimated as 6.165: log likelihood = -619.36, aic = 1252.73 arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), fixed=c(0,NA,NA,NA,NA,NA,NA,NA), transfer=list(c(1,3),c(0,1))) ## Warning in arimax(crude.ukr$Close, order = c(1, 1, 0), xtransf = data.frame(COVID = 1 * : some ## AR parameters were fixed: setting transform.pars = FALSE ## ## Call: ## arimax(x = crude.ukr$Close, order = c(1, 1, 0), fixed = c(0, NA, NA, NA, NA, ## NA, NA, NA), xtransf = data.frame(COVID = 1 * (seq(nrow(crude.ukr)) == 165), ## UR = 1 * (seq(nrow(crude.ukr)) == 269)), transfer = list(c(1, 3), c(0, 1))) ## ## Coefficients: ## ar1 COVID-AR1 COVID-MA0 COVID-MA1 COVID-MA2 COVID-MA3 UR-MA0 UR-MA1 ## 0 0.9036 -6.7365 -2.8745 -9.9998 -11.3642 -1.2627 23.2504 ## s.e. 0 0.0032 2.4649 2.4647 2.4620 2.4619 2.4988 3.5290 ## ## sigma^2 estimated as 6.22: log likelihood = -620.53, aic = 1255.05 arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), fixed=c(NA,NA,NA,0,NA,NA,NA,NA), transfer=list(c(1,3),c(0,1))) ## ## Call: ## arimax(x = crude.ukr$Close, order = c(1, 1, 0), fixed = c(NA, NA, NA, 0, NA, ## NA, NA, NA), xtransf = data.frame(COVID = 1 * (seq(nrow(crude.ukr)) == 165), ## UR = 1 * (seq(nrow(crude.ukr)) == 269)), transfer = list(c(1, 3), c(0, 1))) ## ## Coefficients: ## ar1 COVID-AR1 COVID-MA0 COVID-MA1 COVID-MA2 COVID-MA3 UR-MA0 UR-MA1 ## 0.0780 0.9020 -7.6950 0 -8.8418 -10.0956 0.9246 23.4750 ## s.e. 0.0619 0.0033 2.4405 0 2.4748 2.4754 2.4887 3.6613 ## ## sigma^2 estimated as 6.192: log likelihood = -619.94, aic = 1253.87 Terlihat bahwa membuat koefisien \\(MA(0)\\) di intervensi Ukraina menurunkan AIC dan nampaknya meningkatkan nilai semua koefisien relatif ke s.e-nya: intvmodukr&lt;- arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), fixed=c(NA,NA,NA,NA,NA,NA,0,NA), transfer=list(c(1,3),c(0,1))) Data tidak saling bebas, tetapi semua koefisien beda signifikan dari nol di taraf \\(15\\%\\) checkresiduals(intvmodukr) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,0) ## Q* = 14.131, df = 3, p-value = 0.002732 ## ## Model df: 8. Total lags used: 11 lmtest::coeftest(intvmodukr) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.1119553 0.0611338 1.8313 0.067054 . ## COVID-AR1 0.8776212 0.0085152 103.0651 &lt; 2.2e-16 *** ## COVID-MA0 -7.7107394 2.4211345 -3.1848 0.001449 ** ## COVID-MA1 -3.6060833 2.4529518 -1.4701 0.141535 ## COVID-MA2 -9.6746293 2.4533577 -3.9434 8.033e-05 *** ## COVID-MA3 -10.0562834 2.4282167 -4.1414 3.452e-05 *** ## UR-MA1 24.1400639 2.4833877 9.7206 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Namun ts diag dan ACF menandakan bahwa residual tidak berkorelasi. Kebanyakan garis tidak melewati signifikansi, dan p-values Ljung-Box di berbagai lag berada di atas garis juga. acf(intvmodukr$residuals, lag.max=250, na.action=na.pass) tsdiag(intvmodukr, gof.lag=250,na.action=na.pass) Sekarang, lakukan ramalan dengan model tersebut, dengan fungsi filter: COVID=1*(seq(nrow(weeklyCrude))==165) covreg&lt;-stats::filter(COVID,c(-7.7107, -3.6061, -9.6746, -10.0563 ),&quot;convolution&quot;,sides=1) covreg[is.na(covreg)]&lt;-0 covreg&lt;-stats::filter(covreg,0.1120,&quot;recursive&quot;,sides=1) UR=1*(seq(nrow(weeklyCrude))==269) URReg&lt;-stats::filter(UR,c(0,24.1401),&quot;convolution&quot;,sides=1) Lalu masukkan ke Arima: modfin.ukr&lt;-Arima(crude.ukr$Close,order=c(1,1,0), xreg=cbind(covreg,URReg)[1:270,]) modfin.ukr ## Series: crude.ukr$Close ## Regression with ARIMA(1,1,0) errors ## ## Coefficients: ## ar1 covreg URReg ## 0.1706 0.5341 0.9943 ## s.e. 0.0602 0.1740 0.1071 ## ## sigma^2 = 6.764: log likelihood = -634.94 ## AIC=1277.88 AICc=1278.03 BIC=1292.24 Koefisien intervensi Ukraina mendekati 1, tetapi tidak untuk COVID. Lakukan pendugaan dan plot: forc.inv.ukr&lt;-forecast(modfin.ukr,7,xreg=cbind(covreg,URReg)[272:278,]) weeklyCrude[,`:=`(&quot;fitted.intv&quot;=c(forc.inv.ukr$fitted,rep(NA,8)), &quot;predicted.intv&quot;=c(rep(NA,271),forc.inv.ukr$mean), &quot;lwr.intv&quot;=c(rep(NA,271),forc.inv.ukr$lower[,2]), &quot;upr.intv&quot;=c(rep(NA,271),forc.inv.ukr$upper[,2]))] ggplot(aes(x=Date,y=Close),data=weeklyCrude[260:278])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intv,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.1)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.1)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39; ))+ theme_minimal()+ylab(&quot; &quot;)+ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) Model intervensi menduga harga minyak lebih rendah daripada model intervensi. Namun, tidak terlihat jelas mana model yang lebih baik. Bandingkan nilai akurasi: compAcc&lt;-rbind(accuracy(weeklyCrude$Close, weeklyCrude$predicted.def), accuracy(weeklyCrude$Close, weeklyCrude$predicted.intv)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 17.3866 18.1892 17.3866 14.3930 14.3930 Intervensi -11.6907 12.8181 11.6907 -12.7498 12.7498 Model intervensi memiliki MAE dan RMSE lebih rendah, tapi MAPE lebih tinggi. MAPE memberikan penalti lebih besar pada error yang negatif (Hyndman dan Athanasopoulos 2021), sehingga dalam kasus ini MAE dan RMSE lebih dapat dipercaya - model intervensi baik. Ini juga terlihat di training: compAcc&lt;-rbind(accuracy(weeklyCrude$Close[271:274], weeklyCrude$predicted.def[271:274]), accuracy(weeklyCrude$Close[271:274], weeklyCrude$predicted.intv[271:274])) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 14.5981 15.8018 14.5981 12.1083 12.1083 Intervensi -14.2638 15.4893 14.2638 -15.5560 15.5560 Namun, di jangka waktu pendek model tanpa intervensi lebih baik ramalannya. compAcc&lt;-rbind(accuracy(model1.crude2), accuracy(intvmodukr)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE MASE ACF1 Tanpa Intervensi 0.2038 3.0027 2.0795 0.1035 4.0328 0.9848 -0.0022 Intervensi 0.1278 2.4784 1.9133 -0.0426 3.7524 0.9061 -0.0051 Model intervensi memiliki akurasi lebih baik di training juga. 4.3.3 Rev: Penanganan autokorelasi Model intervensi Ukraina sebelumnya memiliki masalah autokorelasi. Ditemukan bahwa dengan menambah satu term MA pada intervensi COVID, autokorelasi tersebut hilang: intvmod.noautocor&lt;-arimax(crude.ukr$Close,order=c(1,1,0), xtransf=data.frame(COVID=1*(seq(nrow(crude.ukr))==165), UR=1*(seq(nrow(crude.ukr))==269)), fixed=c(NA,NA,NA,NA,NA,NA,NA,0,NA), transfer=list(c(1,4),c(0,1))) Dapat dilihat bahwa ACF tidak melewati garis signifikansi: acf(intvmod.noautocor$residuals, na.action=na.pass) Tidak ada autokorelasi yang berbeda signifikan dari nol di lag sampai 20. Jika ditambah sampai lag yang sangat banyak: acf(intvmod.noautocor$residuals, na.action=na.pass, lag.max=250) Terdapat autokorelasi yang melewati garis, tapi sudah relatif jauh (lebih dari lag 50). Begitu juga untuk tsdiag: tsdiag(intvmod.noautocor, gof.lag=100, na.action=na.pass) Di kebanyakan lag, hipotesis bahwa galat saling bebas tidak ditolak oleh uji Ljung-Box. qqnorm(intvmod.noautocor$residuals) qqline(intvmod.noautocor$residuals) Secara eksploratif residual tampak normal, begitu juga secara uji: nonas&lt;-intvmod.noautocor$residuals[!is.na(intvmod.noautocor$residuals)] ks.test(nonas,pnorm, mean(nonas), sd(nonas)) ## ## One-sample Kolmogorov-Smirnov test ## ## data: nonas ## D = 0.047157, p-value = 0.5951 ## alternative hypothesis: two-sided shapiro.test(nonas) ## ## Shapiro-Wilk normality test ## ## data: nonas ## W = 0.99572, p-value = 0.6778 Residual nampak normal. Forecasting dilakukan dengan melihat koefisien: lmtest::coeftest(intvmod.noautocor) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.197018 0.060626 3.2497 0.001155 ** ## COVID-AR1 -0.078669 0.185484 -0.4241 0.671473 ## COVID-MA0 -5.236379 2.293745 -2.2829 0.022437 * ## COVID-MA1 -4.806999 3.226176 -1.4900 0.136225 ## COVID-MA2 -9.796430 3.547651 -2.7614 0.005756 ** ## COVID-MA3 -14.950299 3.212270 -4.6541 3.254e-06 *** ## COVID-MA4 -11.691369 2.289597 -5.1063 3.285e-07 *** ## UR-MA1 23.987798 2.486882 9.6457 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 intvmod.noautocor ## ## Call: ## arimax(x = crude.ukr$Close, order = c(1, 1, 0), fixed = c(NA, NA, NA, NA, NA, ## NA, NA, 0, NA), xtransf = data.frame(COVID = 1 * (seq(nrow(crude.ukr)) == ## 165), UR = 1 * (seq(nrow(crude.ukr)) == 269)), transfer = list(c(1, 4), ## c(0, 1))) ## ## Coefficients: ## ar1 COVID-AR1 COVID-MA0 COVID-MA1 COVID-MA2 COVID-MA3 COVID-MA4 UR-MA0 UR-MA1 ## 0.1970 -0.0787 -5.2364 -4.8070 -9.7964 -14.9503 -11.6914 0 23.9878 ## s.e. 0.0606 0.1855 2.2937 3.2262 3.5477 3.2123 2.2896 0 2.4869 ## ## sigma^2 estimated as 6.184: log likelihood = -617.44, aic = 1250.88 Ada masalah dalam kasus ini, yaitu koefisien AR tidak signifikan. Walaupun begitu lanjutkan saja forecasting: COVID=1*(seq(nrow(weeklyCrude))==165) covreg&lt;-stats::filter(COVID,c(-5.2364,-4.8070,-9.7964,-14.9503,-11.6914 ),&quot;convolution&quot;,sides=1) covreg[is.na(covreg)]&lt;-0 covreg&lt;-stats::filter(covreg,-0.0787,&quot;recursive&quot;,sides=1) UR=1*(seq(nrow(weeklyCrude))==269) URReg&lt;-stats::filter(UR,c(0,23.9878),&quot;convolution&quot;,sides=1) modfin.ukr&lt;-Arima(crude.ukr$Close,order=c(1,1,0), xreg=cbind(covreg,URReg)[1:270,]) modfin.ukr ## Series: crude.ukr$Close ## Regression with ARIMA(1,1,0) errors ## ## Coefficients: ## ar1 covreg URReg ## 0.1965 0.9999 1.0000 ## s.e. 0.0598 0.1680 0.1031 ## ## sigma^2 = 6.187: log likelihood = -622.99 ## AIC=1253.97 AICc=1254.13 BIC=1268.34 Koefisien regressor mendekati 1 - ini adalah pertanda yang baik. forc.inv.ukr&lt;-forecast(modfin.ukr,8,xreg=cbind(covreg,URReg)[271:278,]) weeklyCrude[,`:=`(&quot;fitted.intvrev&quot;=c(forc.inv.ukr$fitted,rep(NA,8)), &quot;predicted.intvrev&quot;=c(rep(NA,270),forc.inv.ukr$mean), &quot;lwr.intvrev&quot;=c(rep(NA,270),forc.inv.ukr$lower[,2]), &quot;upr.intvrev&quot;=c(rep(NA,270),forc.inv.ukr$upper[,2]))] ggplot(aes(x=Date,y=Close),data=weeklyCrude[260:278])+ geom_point(size=3, alpha=0.3, color=&quot;darkgray&quot;)+ geom_line(aes(y=fitted.intvrev,color=&quot;Fitted&quot;))+ geom_point(aes(y=predicted.def,color=&quot;Tanpa Intervensi&quot;), size=3, alpha=0.5)+ geom_ribbon(aes(ymin=lwr.def,ymax=upr.def, color=&quot;Tanpa Intervensi&quot;, fill=&quot;Tanpa Intervensi&quot;),alpha=0.1)+ geom_point(aes(y=predicted.intv,color=&quot;Intervensi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intv,ymax=upr.intv, color=&quot;Intervensi&quot;, fill=&quot;Intervensi&quot;),alpha=0.1)+ geom_point(aes(y=predicted.intvrev,color=&quot;Revisi&quot;),size=3,alpha=0.5)+ geom_ribbon(aes(ymin=lwr.intvrev,ymax=upr.intvrev, color=&quot;Revisi&quot;, fill=&quot;Revisi&quot;),alpha=0.1)+ scale_color_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39;, &#39;Revisi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39;, &#39;Revisi&#39; = &#39;#56B4E9&#39;))+ scale_fill_manual(name=&#39;Prediksi ARIMA&#39;, breaks=c(&#39;Fitted&#39;, &#39;Tanpa Intervensi&#39;, &#39;Intervensi&#39;, &#39;Revisi&#39; ), values=c(&#39;Fitted&#39;=&#39;black&#39;, &#39;Tanpa Intervensi&#39;=&#39;#DB0000&#39;, &#39;Intervensi&#39;=&#39;#E69F00&#39;, &#39;Revisi&#39; = &#39;#56B4E9&#39;))+ theme_minimal()+ylab(&quot; &quot;)+ggtitle(&quot; Perbandingan Model Intervensi dan non-Intervensi terbaik&quot;) ## Warning: Removed 8 row(s) containing missing values (geom_path). ## Warning: Removed 12 rows containing missing values (geom_point). ## Removed 12 rows containing missing values (geom_point). ## Warning: Removed 11 rows containing missing values (geom_point). Model intervensi menduga harga minyak lebih rendah daripada model tanpa intervensi, baik yang telah direvisi atau tidak. Namun, tidak terlihat jelas mana model yang lebih baik. Bandingkan nilai akurasi: compAcc&lt;-rbind(accuracy(weeklyCrude$Close, weeklyCrude$predicted.def), accuracy(weeklyCrude$Close, weeklyCrude$predicted.intv), accuracy(weeklyCrude$Close, weeklyCrude$predicted.intvrev)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;,&quot;Revisi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 17.3866 18.1892 17.3866 14.3930 14.3930 Intervensi -11.6907 12.8181 11.6907 -12.7498 12.7498 Revisi -12.4107 13.4935 12.4107 -13.5316 13.5316 Namun, di jangka waktu pendek model tanpa intervensi lebih baik ramalannya menurut MAPE. Model revisi memiliki ramalan terburuk. compAcc&lt;-rbind(accuracy(weeklyCrude$Close[271:274], weeklyCrude$predicted.def[271:274]), accuracy(weeklyCrude$Close[271:274], weeklyCrude$predicted.intv[271:274]), accuracy(weeklyCrude$Close[271:274], weeklyCrude$predicted.intvrev[271:274])) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;, &quot;Revisi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE Tanpa Intervensi 14.5981 15.8018 14.5981 12.1083 12.1083 Intervensi -14.2638 15.4893 14.2638 -15.5560 15.5560 Revisi -15.0840 16.0316 15.0840 -16.4465 16.4465 Model intervensi memiliki MAE dan RMSE lebih rendah, tapi MAPE lebih tinggi. MAPE memberikan penalti lebih besar pada error yang negatif (Hyndman dan Athanasopoulos 2021), sehingga dalam kasus ini MAE dan RMSE lebih dapat dipercaya - model intervensi baik. Ini juga terlihat di training: compAcc&lt;-rbind(accuracy(model1.crude2), accuracy(intvmodukr), accuracy(intvmod.noautocor)) rownames(compAcc)&lt;-c(&quot;Tanpa Intervensi&quot;,&quot;Intervensi&quot;,&quot;Revisi&quot;) knitr::kable( compAcc, row.names=T, digits =4 ) ME RMSE MAE MPE MAPE MASE ACF1 Tanpa Intervensi 0.2038 3.0027 2.0795 0.1035 4.0328 0.9848 -0.0022 Intervensi 0.1278 2.4784 1.9133 -0.0426 3.7524 0.9061 -0.0051 Revisi 0.1146 2.4820 1.9502 0.0071 3.7983 0.9236 -0.0183 Akurasi model revisi lebih baik dari intervensi. References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
